

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Tutorial &mdash; msprime 0.7.5 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API Documentation" href="api.html" />
    <link rel="prev" title="Installation" href="installation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> msprime
          

          
          </a>

          
            
            
              <div class="version">
                0.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#simulating-trees">Simulating trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="#recombination">Recombination</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mutations">Mutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#variants">Variants</a></li>
<li class="toctree-l2"><a class="reference internal" href="#historical-samples">Historical samples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#replication">Replication</a></li>
<li class="toctree-l2"><a class="reference internal" href="#population-structure">Population structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#demography">Demography</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#census-events">Census events</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#recombination-maps">Recombination maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multiple-chromosomes">Multiple chromosomes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hybrid-simulations">Hybrid simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#completing-forwards-simulations">Completing forwards simulations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#why-record-the-initial-generation">Why record the initial generation?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#topology-gotchas">Topology gotchas</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#recording-the-full-arg">Recording the full ARG</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="cli.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="CITATION.html">Citing msprime</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">msprime</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Tutorial</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/tutorial.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tutorial">
<span id="sec-tutorial"></span><h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<p>This is the tutorial for the Python interface to the <code class="docutils literal notranslate"><span class="pre">msprime</span></code>
library. Detailed <a class="reference internal" href="api.html#sec-api"><span class="std std-ref">API Documentation</span></a> is also available for this
library. An <strong class="program">ms</strong> compatible <a class="reference internal" href="cli.html#sec-cli"><span class="std std-ref">command line interface</span></a>
is also available if you wish to use <code class="docutils literal notranslate"><span class="pre">msprime</span></code> directly within
an existing work flow.
Please see the <a class="reference external" href="https://tskit.readthedocs.io/en/stable">tskit documentation</a> for
more information on how to use the
<a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html">tskit Python API</a>
to analyse simulation results.</p>
<div class="section" id="simulating-trees">
<h2>Simulating trees<a class="headerlink" href="#simulating-trees" title="Permalink to this headline">¶</a></h2>
<p>Running simulations is very straightforward in <code class="docutils literal notranslate"><span class="pre">msprime</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">msprime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree_sequence</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">sample_size</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;unicode&quot;</span><span class="p">))</span>

<span class="go">    10</span>
<span class="go"> ┏━━┻━┓</span>
<span class="go"> ┃    9</span>
<span class="go"> ┃  ┏━┻━┓</span>
<span class="go"> 8  ┃   ┃</span>
<span class="go">┏┻┓ ┃   ┃</span>
<span class="go">┃ ┃ ┃   7</span>
<span class="go">┃ ┃ ┃ ┏━┻┓</span>
<span class="go">┃ ┃ ┃ ┃  6</span>
<span class="go">┃ ┃ ┃ ┃ ┏┻┓</span>
<span class="go">3 5 0 4 1 2</span>
</pre></div>
</div>
<p>Here, we simulate the coalescent for a sample of size six
with an effective population size of 1000 diploids,
and then print out a depiction of the resulting tree.
The <code class="docutils literal notranslate"><span class="pre">msprime</span></code> library uses
<a class="reference external" href="https://tskit.readthedocs.io/en/stable">tskit</a>
to represent simulation results and
the <a class="reference internal" href="api.html#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a> function returns a
<a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.TreeSequence</span></code></a> object, which provides a very
efficient way to access the correlated trees in simulations
involving recombination. In this example we know that
there can only be one tree because we have not provided
a value for <code class="docutils literal notranslate"><span class="pre">recombination_rate</span></code>, and it
defaults to zero.
Therefore, we access the only tree in the
sequence using the <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence.first" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">first()</span></code></a> method.
Finally, we draw a simple depiction of the tree to the terminal
using the <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.Tree.draw" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tskit.Tree.draw()</span></code></a> method.</p>
<p>Genealogical trees record the lines of descent along which genomes
have been inherited. Since diploids have two copies of each autosomal
chromosome, diploid individuals contain two such lines of descent:
the simulation above provides the genealogical history of only three diploids.</p>
<p>Trees are represented within <code class="docutils literal notranslate"><span class="pre">tskit</span></code> (and therefore <code class="docutils literal notranslate"><span class="pre">msprime</span></code>)
in a slightly unusual way. In
the majority of libraries dealing with trees, each node is
represented as an object in memory and the relationship
between nodes as pointers between these objects. In <code class="docutils literal notranslate"><span class="pre">tskit</span></code>,
however, nodes are <em>integers</em>.
In the tree above, we can see that the leaves of the tree
are labelled with 0 to 5, and all the internal nodes of the tree
are also integers with the root of the tree being 10.</p>
<p>We can easily trace our path
back to the root for a particular sample using the
<a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.Tree.parent" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parent()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;node </span><span class="si">{}</span><span class="s2">: time = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">u</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">u</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="go">node 2: time = 0.0</span>
<span class="go">node 6: time = 11.59282234272971</span>
<span class="go">node 7: time = 129.57841077196494</span>
<span class="go">node 9: time = 1959.4591339636365</span>
<span class="go">node 10: time = 5379.737460469677</span>
</pre></div>
</div>
<p>In this code chunk we iterate up the tree starting at node 0 and
stop when we get to the root. We know that a node is a root
if its parent is <code class="xref py py-const docutils literal notranslate"><span class="pre">tskit.NULL</span></code>, which is a special
reserved node. (The value of the null node is -1, but we recommend
using the symbolic constant to make code more readable.) We also use
the <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.Tree.time" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time()</span></code></a> method to get the time
for each node, which corresponds to the time in generations
at which the coalescence event happened during the simulation.
We can also obtain the length of a branch joining a node to
its parent using the <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.Tree.branch_length" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">branch_length()</span></code></a>
method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">branch_length</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="go">117.98558842923524</span>
</pre></div>
</div>
<p>The branch length for node 6 is about 118 generations, since
the birth times of node 6 was 11 generations ago, and the birth time of its
parent, node 7, was around 129 generations ago.
It is also
often useful to obtain the total branch length of the tree, i.e.,
the sum of the lengths of all branches:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">total_branch_length</span><span class="p">)</span>
<span class="go">13238.125493096279</span>
</pre></div>
</div>
</div>
<div class="section" id="recombination">
<h2>Recombination<a class="headerlink" href="#recombination" title="Permalink to this headline">¶</a></h2>
<p>Simulating the history of a single locus is a very useful, but we are most
often interesting in simulating the history of our sample across large genomic
regions under the influence of recombination. The <code class="docutils literal notranslate"><span class="pre">msprime</span></code> API is
specifically designed to make this common requirement both easy and efficient.
To model genomic sequences under the influence of recombination we have
two parameters to the <a class="reference internal" href="api.html#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a> function.
The <code class="docutils literal notranslate"><span class="pre">length</span></code> parameter specifies the length of the simulated sequence,
and is a floating point number, so recombination (and mutation) can
occur at any location along the sequence (the units are arbitrary).
If <code class="docutils literal notranslate"><span class="pre">length</span></code> is not supplied, it is assumed to be 1.0. The <code class="docutils literal notranslate"><span class="pre">recombination_rate</span></code>
parameter specifies the rate of crossing over per unit of length per generation,
and is zero by default. See the <a class="reference internal" href="api.html#sec-api"><span class="std std-ref">API Documentation</span></a> for a discussion of the precise
recombination model used.</p>
<p>Here, we simulate the trees across over a 10kb region with a recombination
rate of <span class="math notranslate nohighlight">\(2 \times 10^{-8}\)</span> per base per generation, with a diploid
effective population size of 1000:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tree_sequence</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">sample_size</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mf">1e4</span><span class="p">,</span> <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">2e-8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">trees</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tree </span><span class="si">{}</span><span class="s2">: interval = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">interval</span><span class="p">))</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;unicode&quot;</span><span class="p">))</span>
<span class="go">--------------------</span>
<span class="go">tree 0: interval = (0.0,  6016.224463474058)</span>
<span class="go">   11</span>
<span class="go">┏━━┻━━┓</span>
<span class="go">┃     10</span>
<span class="go">┃  ┏━━┻━┓</span>
<span class="go">┃  ┃    9</span>
<span class="go">┃  ┃  ┏━┻┓</span>
<span class="go">┃  7  ┃  ┃</span>
<span class="go">┃ ┏┻┓ ┃  ┃</span>
<span class="go">┃ ┃ ┃ ┃  6</span>
<span class="go">┃ ┃ ┃ ┃ ┏┻┓</span>
<span class="go">3 0 1 2 4 5</span>

<span class="go">--------------------</span>
<span class="go">tree 1: interval = (6016.224463474058, 10000.0)</span>
<span class="go">     10</span>
<span class="go">  ┏━━┻━━┓</span>
<span class="go">  9     ┃</span>
<span class="go">┏━┻┓    ┃</span>
<span class="go">┃  ┃    8</span>
<span class="go">┃  ┃  ┏━┻┓</span>
<span class="go">┃  ┃  ┃  7</span>
<span class="go">┃  ┃  ┃ ┏┻┓</span>
<span class="go">┃  6  ┃ ┃ ┃</span>
<span class="go">┃ ┏┻┓ ┃ ┃ ┃</span>
<span class="go">2 4 5 3 0 1</span>
</pre></div>
</div>
<p>In this example, we use the <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence.trees" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tskit.TreeSequence.trees()</span></code></a>
method to iterate over the trees in the sequence. For each tree
we print out its index (i.e., its position in the sequence) and
the interval the tree covers (i.e., the genomic
coordinates which all share precisely this tree) using the
<a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.Tree.index" title="(in tskit v0.3)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tskit.Tree.index</span></code></a> and <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.Tree.interval" title="(in tskit v0.3)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tskit.Tree.interval</span></code></a> attributes.
Thus, the first tree covers the
first 6kb of sequence and the second tree covers the remaining 4kb.
We can see
that these trees share a great deal of their structure, but that there are
also important differences between the trees.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Do not store the values returned from the
<a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence.trees" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trees()</span></code></a> iterator in a list and operate
on them afterwards! For efficiency reasons <code class="docutils literal notranslate"><span class="pre">tskit</span></code> uses the same
instance of <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.Tree" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.Tree</span></code></a> for each tree in the sequence
and updates the internal state for each new tree. Therefore, if you store
the trees returned from the iterator in a list, they will all refer
to the same tree.</p>
</div>
</div>
<div class="section" id="mutations">
<h2>Mutations<a class="headerlink" href="#mutations" title="Permalink to this headline">¶</a></h2>
<p>Mutations are generated in <code class="docutils literal notranslate"><span class="pre">msprime</span></code> by throwing mutations down
on the branches of trees at a particular rate. The mutations are
generated under the infinite sites model, and so each mutation
occurs at a unique (floating point) point position along the
genomic interval occupied by a tree. The mutation rate for simulations
is specified using the <code class="docutils literal notranslate"><span class="pre">mutation_rate</span></code> parameter of
<a class="reference internal" href="api.html#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>. For example, the following chunk simulates 50kb
of nonrecombining sequence with a mutation rate of <span class="math notranslate nohighlight">\(1 \times 10^{-8}\)</span>
per base per generation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tree_sequence</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">sample_size</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mf">50e3</span><span class="p">,</span> <span class="n">mutation_rate</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">sites</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">mutation</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">mutations</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mutation @ position </span><span class="si">{:.2f}</span><span class="s2"> over node </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
<span class="gp">... </span>            <span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">mutation</span><span class="o">.</span><span class="n">node</span><span class="p">))</span>
<span class="go">Mutation @ position 1556.54 over node 9</span>
<span class="go">Mutation @ position 4485.17 over node 6</span>
<span class="go">Mutation @ position 9788.56 over node 6</span>
<span class="go">Mutation @ position 11759.03 over node 6</span>
<span class="go">Mutation @ position 11949.32 over node 6</span>
<span class="go">Mutation @ position 14321.77 over node 9</span>
<span class="go">Mutation @ position 31454.99 over node 6</span>
<span class="go">Mutation @ position 45125.69 over node 9</span>
<span class="go">Mutation @ position 49709.68 over node 6</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;unicode&quot;</span><span class="p">))</span>
<span class="go">    10</span>
<span class="go"> ┏━━┻━━┓</span>
<span class="go"> ┃     9</span>
<span class="go"> ┃   ┏━┻━┓</span>
<span class="go"> ┃   ┃   8</span>
<span class="go"> ┃   ┃  ┏┻┓</span>
<span class="go"> ┃   7  ┃ ┃</span>
<span class="go"> ┃  ┏┻┓ ┃ ┃</span>
<span class="go"> 6  ┃ ┃ ┃ ┃</span>
<span class="go">┏┻┓ ┃ ┃ ┃ ┃</span>
<span class="go">0 4 2 5 1 3</span>
</pre></div>
</div>
<p>It is also possible to add mutations to an existing tree sequence
using the <a class="reference internal" href="api.html#msprime.mutate" title="msprime.mutate"><code class="xref py py-func docutils literal notranslate"><span class="pre">msprime.mutate()</span></code></a> function.</p>
</div>
<div class="section" id="variants">
<h2>Variants<a class="headerlink" href="#variants" title="Permalink to this headline">¶</a></h2>
<p>We are often interesting in accessing the sequence data that results from
simulations directly. The most efficient way to do this is by using
the <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence.variants" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tskit.TreeSequence.variants()</span></code></a> method, which returns an iterator
over all the <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.Variant" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.Variant</span></code></a> objects arising from the trees and mutations.
Each variant contains a reference to the site object, as well as the
alleles and the observed sequences for each sample in the <code class="docutils literal notranslate"><span class="pre">genotypes</span></code>
field:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tree_sequence</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">sample_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="mf">1e4</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mf">5e3</span><span class="p">,</span> <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">2e-8</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mutation_rate</span><span class="o">=</span><span class="mf">2e-8</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">variant</span> <span class="ow">in</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">variants</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">variant</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">variant</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">variant</span><span class="o">.</span><span class="n">alleles</span><span class="p">,</span> <span class="n">variant</span><span class="o">.</span><span class="n">genotypes</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">0       2432.768327416852       (&#39;0&#39;, &#39;1&#39;)      [0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0]</span>
<span class="go">1       2577.6939414924095      (&#39;0&#39;, &#39;1&#39;)      [1 0 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1]</span>
<span class="go">2       2844.682702049562       (&#39;0&#39;, &#39;1&#39;)      [0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0]</span>
<span class="go">3       4784.266628557816       (&#39;0&#39;, &#39;1&#39;)      [0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0]</span>
</pre></div>
</div>
<p>In this example we simulate some data and then print out the observed
sequences. We loop through each variant and print out the observed state of
each sample as an array of zeros and ones, along with the index and position
of the corresponding mutation.  In this example, the
alleles are always <code class="docutils literal notranslate"><span class="pre">'0'</span></code> (the ancestral state) and <code class="docutils literal notranslate"><span class="pre">'1'</span></code>
(the derived state), because we are simulating with the infinite sites mutation
model, in which each mutation occurs at a unique position in the genome.
More complex models are possible, however.</p>
<p>This way of working with the sequence data is quite efficient because we
do not need to keep the entire genotype matrix in memory at once. However, if
we do want the full genotype matrix it is simple to obtain:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">genotype_matrix</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
<p>In this example, we run the same simulation but this time
store the entire variant matrix in a two-dimensional numpy array.
This is useful for integrating with tools such as
<a class="reference external" href="https://scikit-allel.readthedocs.io/en/latest/">scikit allel</a>,
but note that what we call genotype matrix corresponds to a
scikit-allel haplotype array.</p>
</div>
<div class="section" id="historical-samples">
<h2>Historical samples<a class="headerlink" href="#historical-samples" title="Permalink to this headline">¶</a></h2>
<p>Simulating coalescent histories in which some of the samples are not
from the present time is straightforward in <code class="docutils literal notranslate"><span class="pre">msprime</span></code>.
By using the <code class="docutils literal notranslate"><span class="pre">samples</span></code> argument to <a class="reference internal" href="api.html#msprime.simulate" title="msprime.simulate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">msprime.simulate()</span></code></a>
we can specify the location and time at which all samples are made.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">historical_samples_example</span><span class="p">():</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">Sample</span><span class="p">(</span><span class="n">population</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">Sample</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>  <span class="c1"># Or, we can use positional arguments.</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">Sample</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">Sample</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">tree_seq</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">tree_seq</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">tree</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;unicode&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>In this example we create four samples, two taken at the present time
and two taken 1.0 generations in the past, as might represent one modern
and one ancient diploid individual. There are a number of
different ways in which we can describe the samples using the
<code class="docutils literal notranslate"><span class="pre">msprime.Sample</span></code> object (samples can be provided as plain tuples also
if more convenient). Running this example, we get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">historical_samples_example</span><span class="p">()</span>
<span class="go">6    -1    2.8240255501413247</span>
<span class="go">4    6    0.0864109319103291</span>
<span class="go">0    4    0.0</span>
<span class="go">1    4    0.0</span>
<span class="go">5    6    1.9249243960710336</span>
<span class="go">2    5    1.0</span>
<span class="go">3    5    1.0</span>
<span class="go">   6</span>
<span class="go"> ┏━┻━┓</span>
<span class="go"> ┃   5</span>
<span class="go"> ┃  ┏┻┓</span>
<span class="go"> ┃  2 3</span>
<span class="go"> ┃</span>
<span class="go"> 4</span>
<span class="go">┏┻┓</span>
<span class="go">0 1</span>
</pre></div>
</div>
<p>Because nodes <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">1</span></code> were sampled at time 0, their times in the tree
are both 0. Nodes <code class="docutils literal notranslate"><span class="pre">2</span></code> and <code class="docutils literal notranslate"><span class="pre">3</span></code> were sampled at time 1.0, and so their times are recorded
as 1.0 in the tree.</p>
</div>
<div class="section" id="replication">
<h2>Replication<a class="headerlink" href="#replication" title="Permalink to this headline">¶</a></h2>
<p>A common task for coalescent simulations is to check the accuracy of analytical
approximations to statistics of interest. To do this, we require many independent
replicates of a given simulation. <code class="docutils literal notranslate"><span class="pre">msprime</span></code> provides a simple and efficient
API for replication: by providing the <code class="docutils literal notranslate"><span class="pre">num_replicates</span></code> argument to the
<a class="reference internal" href="api.html#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a> function, we can iterate over the replicates
in a straightforward manner. Here is an example where we compare the
analytical results for the number of segregating sites with simulations:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">msprime</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">segregating_sites_example</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">num_replicates</span><span class="p">):</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_replicates</span><span class="p">)</span>
    <span class="n">replicates</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
        <span class="n">Ne</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">sample_size</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
        <span class="n">mutation_rate</span><span class="o">=</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">num_replicates</span><span class="o">=</span><span class="n">num_replicates</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">tree_sequence</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">replicates</span><span class="p">):</span>
        <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_sites</span>
    <span class="c1"># Now, calculate the analytical predictions</span>
    <span class="n">S_mean_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">theta</span>
    <span class="n">S_var_a</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">theta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">+</span>
        <span class="n">theta</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;              mean              variance&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Observed      </span><span class="si">{}</span><span class="se">\t\t</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">S</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Analytical    </span><span class="si">{:.5f}</span><span class="se">\t\t</span><span class="si">{:.5f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">S_mean_a</span><span class="p">,</span> <span class="n">S_var_a</span><span class="p">))</span>
</pre></div>
</div>
<p>Running this code, we get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">segregating_sites_example</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>
<span class="go">          mean              variance</span>
<span class="go">Observed      14.17893          53.0746740551</span>
<span class="go">Analytical    14.14484          52.63903</span>
</pre></div>
</div>
<p>Note that in this example we set <span class="math notranslate nohighlight">\(N_e = 0.5\)</span> and
the mutation rate to <span class="math notranslate nohighlight">\(\theta / 2\)</span> when calling <a class="reference internal" href="api.html#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>.
This works because <code class="docutils literal notranslate"><span class="pre">msprime</span></code> simulates Kingman’s coalescent,
for which <span class="math notranslate nohighlight">\(N_e\)</span> is only a time scaling;
since <span class="math notranslate nohighlight">\(N_e\)</span> is the diploid effective population size,
setting <span class="math notranslate nohighlight">\(N_e = 0.5\)</span> means that the mean time for two samples to coalesce
is equal to one time unit in the resulting trees.
This is helpful for converting the diploid per-generation time units
of msprime into the haploid coalescent units used in many
theoretical results. However, it is important to note that conventions
vary widely, and great care is needed with such factor-of-two
rescalings.</p>
</div>
<div class="section" id="population-structure">
<h2>Population structure<a class="headerlink" href="#population-structure" title="Permalink to this headline">¶</a></h2>
<p>Population structure in <code class="docutils literal notranslate"><span class="pre">msprime</span></code> closely follows the model used in the
<code class="docutils literal notranslate"><span class="pre">ms</span></code> simulator: we have <span class="math notranslate nohighlight">\(N\)</span> subpopulations with an <span class="math notranslate nohighlight">\(N\times N\)</span>
matrix describing the migration rates between these subpopulations. The
sample sizes, population sizes and growth rates of all subpopulations
can be specified independently. Migration rates are specified using
a migration matrix. Unlike <code class="docutils literal notranslate"><span class="pre">ms</span></code> however, all times and rates are specified
in generations and all populations sizes are absolute (that is, not
multiples of <span class="math notranslate nohighlight">\(N_e\)</span>).</p>
<p>In the following example, we calculate the mean coalescence time for
a pair of lineages sampled in different subpopulations in a symmetric island
model, and compare this with the analytical expectation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">msprime</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">migration_example</span><span class="p">(</span><span class="n">num_replicates</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="mi">4</span><span class="p">):</span>
    <span class="c1"># M is the overall symmetric migration rate, and d is the number</span>
    <span class="c1"># of subpopulations.</span>
    <span class="n">M</span> <span class="o">=</span> <span class="mf">0.2</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c1"># Allocate the initial sample. Because we are interested in the</span>
    <span class="c1"># between-subpopulation coalescence times, we choose one sample each</span>
    <span class="c1"># from the first two subpopulations.</span>
    <span class="n">population_configurations</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">PopulationConfiguration</span><span class="p">(</span><span class="n">sample_size</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">PopulationConfiguration</span><span class="p">(</span><span class="n">sample_size</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">PopulationConfiguration</span><span class="p">(</span><span class="n">sample_size</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
    <span class="c1"># Now we set up the migration matrix. Since this is a symmetric</span>
    <span class="c1"># island model, we have the same rate of migration between all</span>
    <span class="c1"># pairs of subpopulations. Diagonal elements must be zero.</span>
    <span class="n">migration_matrix</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">],</span>
        <span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">],</span>
        <span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
    <span class="c1"># We pass these values to the simulate function, and ask it</span>
    <span class="c1"># to run the required number of replicates.</span>
    <span class="n">replicates</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">Ne</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">population_configurations</span><span class="o">=</span><span class="n">population_configurations</span><span class="p">,</span>
        <span class="n">migration_matrix</span><span class="o">=</span><span class="n">migration_matrix</span><span class="p">,</span>
        <span class="n">num_replicates</span><span class="o">=</span><span class="n">num_replicates</span><span class="p">)</span>
    <span class="c1"># And then iterate over these replicates</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_replicates</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tree_sequence</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">replicates</span><span class="p">):</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
        <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">root</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span>
    <span class="c1"># Finally, calculate the analytical expectation and print</span>
    <span class="c1"># out the results</span>
    <span class="n">analytical</span> <span class="o">=</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">M</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Observed  =&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Predicted =&quot;</span><span class="p">,</span> <span class="n">analytical</span><span class="p">)</span>
</pre></div>
</div>
<p>Again, we set <span class="math notranslate nohighlight">\(N_e = 0.5\)</span> to agree with convention in theoretical results,
where usually one coalescent time unit is, in generations, the effective number of <em>haploid</em> individuals.
Running this example we get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">migration_example</span><span class="p">()</span>
<span class="go">Observed  = 3.254904176088153</span>
<span class="go">Predicted = 3.25</span>
</pre></div>
</div>
</div>
<div class="section" id="demography">
<h2>Demography<a class="headerlink" href="#demography" title="Permalink to this headline">¶</a></h2>
<p>Msprime provides a flexible and simple way to model past demographic events
in arbitrary combinations. Here is an example describing the
<a class="reference external" href="http://dx.doi.org/10.1371/journal.pgen.1000695">Gutenkunst et al.</a>
out-of-Africa model. See
<a class="reference external" href="http://dx.doi.org/10.1371/journal.pgen.1000695.g002">Figure 2B</a>
for a schematic of this model, and
<a class="reference external" href="http://dx.doi.org/10.1371/journal.pgen.1000695.t001">Table 1</a> for
the values used.
Coalescent simulation moves from the present back into the past,
so times are in units of generations <em>ago</em>, and we build the model
with most recent events first.</p>
<p>The code below is provided as an example to help you develop your
own models. If you want to use this precise model in your analyses
we strongly recommend using
<a class="reference external" href="https://stdpopsim.readthedocs.io/en/stable/introduction.html#sec-introduction">stdpopsim</a>
which provides a community maintained
<a class="reference external" href="https://stdpopsim.readthedocs.io/en/stable/catalog.html#sec-catalog">catalog</a>
of simulation species information and demographic models. The
model given here is identical to the
<a class="reference external" href="https://stdpopsim.readthedocs.io/en/stable/catalog.html#sec_catalog_homsap_models_outofafrica_3g09">HomSam/OutOfAfrica_3G09</a>
model.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The version of this model in the tutorial from 31 May 2016 to 29 May 2020
(on the stable branch) was <strong>incorrect</strong>. Specifically, it mistakenly
allowed for migration to continue beyond the merger of the African and
Eurasian bottleneck populations. This has now been fixed, but if you had
copied this model from the tutorial for your own analyses, you should
update your model code or use the implementation that has been verified in
<a class="reference external" href="https://stdpopsim.readthedocs.io/en/stable/introduction.html#sec-introduction">stdpopsim</a>.
See <a class="reference external" href="https://github.com/jeromekelleher/msprime-model-errors">here</a> for more
details on the faulty model and its likely effects on downstream analyses.</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="k">def</span> <span class="nf">out_of_africa</span><span class="p">():</span>
    <span class="c1"># First we set out the maximum likelihood values of the various parameters</span>
    <span class="c1"># given in Table 1.</span>
    <span class="n">N_A</span> <span class="o">=</span> <span class="mi">7300</span>
    <span class="n">N_B</span> <span class="o">=</span> <span class="mi">2100</span>
    <span class="n">N_AF</span> <span class="o">=</span> <span class="mi">12300</span>
    <span class="n">N_EU0</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">N_AS0</span> <span class="o">=</span> <span class="mi">510</span>
    <span class="c1"># Times are provided in years, so we convert into generations.</span>
    <span class="n">generation_time</span> <span class="o">=</span> <span class="mi">25</span>
    <span class="n">T_AF</span> <span class="o">=</span> <span class="mf">220e3</span> <span class="o">/</span> <span class="n">generation_time</span>
    <span class="n">T_B</span> <span class="o">=</span> <span class="mf">140e3</span> <span class="o">/</span> <span class="n">generation_time</span>
    <span class="n">T_EU_AS</span> <span class="o">=</span> <span class="mf">21.2e3</span> <span class="o">/</span> <span class="n">generation_time</span>
    <span class="c1"># We need to work out the starting (diploid) population sizes based on</span>
    <span class="c1"># the growth rates provided for these two populations</span>
    <span class="n">r_EU</span> <span class="o">=</span> <span class="mf">0.004</span>
    <span class="n">r_AS</span> <span class="o">=</span> <span class="mf">0.0055</span>
    <span class="n">N_EU</span> <span class="o">=</span> <span class="n">N_EU0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">r_EU</span> <span class="o">*</span> <span class="n">T_EU_AS</span><span class="p">)</span>
    <span class="n">N_AS</span> <span class="o">=</span> <span class="n">N_AS0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">r_AS</span> <span class="o">*</span> <span class="n">T_EU_AS</span><span class="p">)</span>
    <span class="c1"># Migration rates during the various epochs.</span>
    <span class="n">m_AF_B</span> <span class="o">=</span> <span class="mf">25e-5</span>
    <span class="n">m_AF_EU</span> <span class="o">=</span> <span class="mf">3e-5</span>
    <span class="n">m_AF_AS</span> <span class="o">=</span> <span class="mf">1.9e-5</span>
    <span class="n">m_EU_AS</span> <span class="o">=</span> <span class="mf">9.6e-5</span>
    <span class="c1"># Population IDs correspond to their indexes in the population</span>
    <span class="c1"># configuration array. Therefore, we have 0=YRI, 1=CEU and 2=CHB</span>
    <span class="c1"># initially.</span>
    <span class="n">population_configurations</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">PopulationConfiguration</span><span class="p">(</span>
            <span class="n">sample_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="n">N_AF</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">PopulationConfiguration</span><span class="p">(</span>
            <span class="n">sample_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="n">N_EU</span><span class="p">,</span> <span class="n">growth_rate</span><span class="o">=</span><span class="n">r_EU</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">PopulationConfiguration</span><span class="p">(</span>
            <span class="n">sample_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="n">N_AS</span><span class="p">,</span> <span class="n">growth_rate</span><span class="o">=</span><span class="n">r_AS</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">migration_matrix</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span>      <span class="mi">0</span><span class="p">,</span> <span class="n">m_AF_EU</span><span class="p">,</span> <span class="n">m_AF_AS</span><span class="p">],</span>
        <span class="p">[</span><span class="n">m_AF_EU</span><span class="p">,</span>       <span class="mi">0</span><span class="p">,</span> <span class="n">m_EU_AS</span><span class="p">],</span>
        <span class="p">[</span><span class="n">m_AF_AS</span><span class="p">,</span> <span class="n">m_EU_AS</span><span class="p">,</span>       <span class="mi">0</span><span class="p">],</span>
    <span class="p">]</span>
    <span class="n">demographic_events</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># CEU and CHB merge into B with rate changes at T_EU_AS</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">MassMigration</span><span class="p">(</span>
            <span class="n">time</span><span class="o">=</span><span class="n">T_EU_AS</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span><span class="mf">1.0</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">MigrationRateChange</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">T_EU_AS</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">MigrationRateChange</span><span class="p">(</span>
            <span class="n">time</span><span class="o">=</span><span class="n">T_EU_AS</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="n">m_AF_B</span><span class="p">,</span> <span class="n">matrix_index</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">MigrationRateChange</span><span class="p">(</span>
            <span class="n">time</span><span class="o">=</span><span class="n">T_EU_AS</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="n">m_AF_B</span><span class="p">,</span> <span class="n">matrix_index</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">PopulationParametersChange</span><span class="p">(</span>
            <span class="n">time</span><span class="o">=</span><span class="n">T_EU_AS</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="n">N_B</span><span class="p">,</span> <span class="n">growth_rate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">population_id</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="c1"># Population B merges into YRI at T_B</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">MassMigration</span><span class="p">(</span>
            <span class="n">time</span><span class="o">=</span><span class="n">T_B</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span><span class="mf">1.0</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">MigrationRateChange</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">T_B</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="c1"># Size changes to N_A at T_AF</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">PopulationParametersChange</span><span class="p">(</span>
            <span class="n">time</span><span class="o">=</span><span class="n">T_AF</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="n">N_A</span><span class="p">,</span> <span class="n">population_id</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="c1"># Use the demography debugger to print out the demographic history</span>
    <span class="c1"># that we have just described.</span>
    <span class="n">dd</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">DemographyDebugger</span><span class="p">(</span>
        <span class="n">population_configurations</span><span class="o">=</span><span class="n">population_configurations</span><span class="p">,</span>
        <span class="n">migration_matrix</span><span class="o">=</span><span class="n">migration_matrix</span><span class="p">,</span>
        <span class="n">demographic_events</span><span class="o">=</span><span class="n">demographic_events</span><span class="p">)</span>
    <span class="n">dd</span><span class="o">.</span><span class="n">print_history</span><span class="p">()</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="api.html#msprime.DemographyDebugger" title="msprime.DemographyDebugger"><code class="xref py py-class docutils literal notranslate"><span class="pre">DemographyDebugger</span></code></a> provides a method to debug the history that
you have described so that you can be sure that the migration rates, population
sizes and growth rates are all as you intend during each epoch:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">=============================</span>
<span class="n">Epoch</span><span class="p">:</span> <span class="mi">0</span> <span class="o">--</span> <span class="mf">848.0</span> <span class="n">generations</span>
<span class="o">=============================</span>
     <span class="n">start</span>     <span class="n">end</span>      <span class="n">growth_rate</span> <span class="o">|</span>     <span class="mi">0</span>        <span class="mi">1</span>        <span class="mi">2</span>
   <span class="o">--------</span> <span class="o">--------</span>       <span class="o">--------</span> <span class="o">|</span> <span class="o">--------</span> <span class="o">--------</span> <span class="o">--------</span>
<span class="mi">0</span> <span class="o">|</span><span class="mf">1.23e+04</span> <span class="mf">1.23e+04</span>              <span class="mi">0</span> <span class="o">|</span>     <span class="mi">0</span>      <span class="mf">3e-05</span>   <span class="mf">1.9e-05</span>
<span class="mi">1</span> <span class="o">|</span><span class="mf">2.97e+04</span>   <span class="mf">1e+03</span>           <span class="mf">0.004</span> <span class="o">|</span>   <span class="mf">3e-05</span>      <span class="mi">0</span>     <span class="mf">9.6e-05</span>
<span class="mi">2</span> <span class="o">|</span><span class="mf">5.41e+04</span>    <span class="mi">510</span>           <span class="mf">0.0055</span> <span class="o">|</span>  <span class="mf">1.9e-05</span>  <span class="mf">9.6e-05</span>     <span class="mi">0</span>

<span class="n">Events</span> <span class="o">@</span> <span class="n">generation</span> <span class="mf">848.0</span>
   <span class="o">-</span> <span class="n">Mass</span> <span class="n">migration</span><span class="p">:</span> <span class="n">lineages</span> <span class="n">move</span> <span class="kn">from</span> <span class="mi">2</span> <span class="n">to</span> <span class="mi">1</span> <span class="k">with</span> <span class="n">probability</span> <span class="mf">1.0</span>
   <span class="o">-</span> <span class="n">Migration</span> <span class="n">rate</span> <span class="n">change</span> <span class="n">to</span> <span class="mi">0</span> <span class="n">everywhere</span>
   <span class="o">-</span> <span class="n">Migration</span> <span class="n">rate</span> <span class="n">change</span> <span class="k">for</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="n">to</span> <span class="mf">0.00025</span>
   <span class="o">-</span> <span class="n">Migration</span> <span class="n">rate</span> <span class="n">change</span> <span class="k">for</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="n">to</span> <span class="mf">0.00025</span>
   <span class="o">-</span> <span class="n">Population</span> <span class="n">parameter</span> <span class="n">change</span> <span class="k">for</span> <span class="mi">1</span><span class="p">:</span> <span class="n">initial_size</span> <span class="o">-&gt;</span> <span class="mi">2100</span> <span class="n">growth_rate</span> <span class="o">-&gt;</span> <span class="mi">0</span>
<span class="o">==================================</span>
<span class="n">Epoch</span><span class="p">:</span> <span class="mf">848.0</span> <span class="o">--</span> <span class="mf">5600.0</span> <span class="n">generations</span>
<span class="o">==================================</span>
     <span class="n">start</span>     <span class="n">end</span>      <span class="n">growth_rate</span> <span class="o">|</span>     <span class="mi">0</span>        <span class="mi">1</span>        <span class="mi">2</span>
   <span class="o">--------</span> <span class="o">--------</span>       <span class="o">--------</span> <span class="o">|</span> <span class="o">--------</span> <span class="o">--------</span> <span class="o">--------</span>
<span class="mi">0</span> <span class="o">|</span><span class="mf">1.23e+04</span> <span class="mf">1.23e+04</span>              <span class="mi">0</span> <span class="o">|</span>     <span class="mi">0</span>     <span class="mf">0.00025</span>     <span class="mi">0</span>
<span class="mi">1</span> <span class="o">|</span> <span class="mf">2.1e+03</span>  <span class="mf">2.1e+03</span>              <span class="mi">0</span> <span class="o">|</span>  <span class="mf">0.00025</span>     <span class="mi">0</span>        <span class="mi">0</span>
<span class="mi">2</span> <span class="o">|</span>   <span class="mi">510</span>   <span class="mf">2.27e-09</span>         <span class="mf">0.0055</span> <span class="o">|</span>     <span class="mi">0</span>        <span class="mi">0</span>        <span class="mi">0</span>

<span class="n">Events</span> <span class="o">@</span> <span class="n">generation</span> <span class="mf">5600.0</span>
   <span class="o">-</span> <span class="n">Mass</span> <span class="n">migration</span><span class="p">:</span> <span class="n">lineages</span> <span class="n">move</span> <span class="kn">from</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">0</span> <span class="k">with</span> <span class="n">probability</span> <span class="mf">1.0</span>
<span class="o">===================================</span>
<span class="n">Epoch</span><span class="p">:</span> <span class="mf">5600.0</span> <span class="o">--</span> <span class="mf">8800.0</span> <span class="n">generations</span>
<span class="o">===================================</span>
     <span class="n">start</span>     <span class="n">end</span>      <span class="n">growth_rate</span> <span class="o">|</span>     <span class="mi">0</span>        <span class="mi">1</span>        <span class="mi">2</span>
   <span class="o">--------</span> <span class="o">--------</span>       <span class="o">--------</span> <span class="o">|</span> <span class="o">--------</span> <span class="o">--------</span> <span class="o">--------</span>
<span class="mi">0</span> <span class="o">|</span><span class="mf">1.23e+04</span> <span class="mf">1.23e+04</span>              <span class="mi">0</span> <span class="o">|</span>     <span class="mi">0</span>     <span class="mf">0.00025</span>     <span class="mi">0</span>
<span class="mi">1</span> <span class="o">|</span> <span class="mf">2.1e+03</span>  <span class="mf">2.1e+03</span>              <span class="mi">0</span> <span class="o">|</span>  <span class="mf">0.00025</span>     <span class="mi">0</span>        <span class="mi">0</span>
<span class="mi">2</span> <span class="o">|</span><span class="mf">2.27e-09</span> <span class="mf">5.17e-17</span>         <span class="mf">0.0055</span> <span class="o">|</span>     <span class="mi">0</span>        <span class="mi">0</span>        <span class="mi">0</span>

<span class="n">Events</span> <span class="o">@</span> <span class="n">generation</span> <span class="mf">8800.0</span>
   <span class="o">-</span> <span class="n">Population</span> <span class="n">parameter</span> <span class="n">change</span> <span class="k">for</span> <span class="mi">0</span><span class="p">:</span> <span class="n">initial_size</span> <span class="o">-&gt;</span> <span class="mi">7300</span>
<span class="o">================================</span>
<span class="n">Epoch</span><span class="p">:</span> <span class="mf">8800.0</span> <span class="o">--</span> <span class="n">inf</span> <span class="n">generations</span>
<span class="o">================================</span>
     <span class="n">start</span>     <span class="n">end</span>      <span class="n">growth_rate</span> <span class="o">|</span>     <span class="mi">0</span>        <span class="mi">1</span>        <span class="mi">2</span>
   <span class="o">--------</span> <span class="o">--------</span>       <span class="o">--------</span> <span class="o">|</span> <span class="o">--------</span> <span class="o">--------</span> <span class="o">--------</span>
<span class="mi">0</span> <span class="o">|</span> <span class="mf">7.3e+03</span>  <span class="mf">7.3e+03</span>              <span class="mi">0</span> <span class="o">|</span>     <span class="mi">0</span>        <span class="mi">0</span>        <span class="mi">0</span>
<span class="mi">1</span> <span class="o">|</span> <span class="mf">2.1e+03</span>  <span class="mf">2.1e+03</span>              <span class="mi">0</span> <span class="o">|</span>     <span class="mi">0</span>        <span class="mi">0</span>        <span class="mi">0</span>
<span class="mi">2</span> <span class="o">|</span><span class="mf">5.17e-17</span>     <span class="mi">0</span>            <span class="mf">0.0055</span> <span class="o">|</span>     <span class="mi">0</span>        <span class="mi">0</span>        <span class="mi">0</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The output of the <a class="reference internal" href="api.html#msprime.DemographyDebugger.print_history" title="msprime.DemographyDebugger.print_history"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DemographyDebugger.print_history()</span></code></a> method
is intended only for debugging purposes, and is not meant to be machine
readable. The format is also preliminary; if there is other information
that you think would be useful, please <a class="reference external" href="https://github.com/tskit-dev/msprime/issues">open an issue on GitHub</a></p>
</div>
<p>Once you are satisfied that the demographic history that you have built
is correct, it can then be simulated by calling the <a class="reference internal" href="api.html#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>
function.</p>
<div class="section" id="census-events">
<span id="sec-tutorial-demography-census"></span><h3>Census events<a class="headerlink" href="#census-events" title="Permalink to this headline">¶</a></h3>
<p>Census events allow you to add a node to each branch of the tree sequence at a given time
during the simulation. This can be useful when you wish to study haplotypes that are
ancestral to your simulated sample, or when you wish to know which lineages were present in
which populations at specified times.</p>
<p>For instance, the following code specifies a simulation with two samples drawn from each of
two populations. There are two demographic events: a migration rate change and a census
event. At generation 100 and earlier, the two populations exchange migrants at a rate of
0.05. At generation 5000, a census is performed:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pop_config</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">PopulationConfiguration</span><span class="p">(</span><span class="n">sample_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mig_rate_change</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">MigrationRateChange</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
<span class="go">            population_configurations=[pop_config, pop_config],</span>
<span class="go">            length=1000,</span>
<span class="go">            demographic_events=[mig_rate_change, msprime.CensusEvent(time=5000)],</span>
<span class="go">            recombination_rate=1e-7,</span>
<span class="go">            random_seed=141)</span>
</pre></div>
</div>
<p>The resulting tree sequence has nodes on each tree at the specified census time.
These are the nodes with IDs 8, 9, 10, 11, 12 and 13:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">display</span><span class="p">(</span><span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">()))</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/ts_with_census_nodes.svg"><img alt="A tree sequence with census nodes." src="_images/ts_with_census_nodes.svg" width="800px" /></a>
<p>This tells us that the genetic material ancestral to the present day sample was held within 5 haplotypes at time 5000. The node table shows us that four of these haplotypes (nodes 8, 9, 10 and 11) were in population 0 at this time, and two of these haplotypes (nodes 12 and 13) were in population 1 at this time.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="go">id  flags   population  individual  time    metadata</span>
<span class="go">0   1       0   -1  0.00000000000000</span>
<span class="go">1   1       0   -1  0.00000000000000</span>
<span class="go">2   1       1   -1  0.00000000000000</span>
<span class="go">3   1       1   -1  0.00000000000000</span>
<span class="go">4   0       1   -1  2350.08685279051815</span>
<span class="go">5   0       1   -1  3759.20387382847684</span>
<span class="go">6   0       0   -1  4234.97992185234671</span>
<span class="go">7   0       1   -1  4598.83898042243527</span>
<span class="go">8   1048576 0   -1  5000.00000000000000</span>
<span class="go">9   1048576 0   -1  5000.00000000000000</span>
<span class="go">10  1048576 0   -1  5000.00000000000000</span>
<span class="go">11  1048576 0   -1  5000.00000000000000</span>
<span class="go">12  1048576 1   -1  5000.00000000000000</span>
<span class="go">13  1048576 1   -1  5000.00000000000000</span>
<span class="go">14  0       1   -1  5246.90282987397495</span>
<span class="go">15  0       0   -1  8206.73121309170347</span>
</pre></div>
</div>
<p>If we wish to study these ancestral haplotypes further, we can simplify the tree sequence
with respect to the census nodes and perform subsequent analyses on this simplified tree
sequence.
In this example, <code class="docutils literal notranslate"><span class="pre">ts_anc</span></code> is a tree sequence obtained from the original tree sequence
<code class="docutils literal notranslate"><span class="pre">ts</span></code> by labelling the census nodes as samples and removing all nodes and edges that are
not ancestral to these census nodes.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">flags</span><span class="o">==</span><span class="n">msprime</span><span class="o">.</span><span class="n">NODE_IS_CEN_EVENT</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts_anc</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">nodes</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="recombination-maps">
<h2>Recombination maps<a class="headerlink" href="#recombination-maps" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">msprime</span></code> API allows us to quickly and easily simulate data from an
arbitrary recombination map. In this example we read a recombination
map for human chromosome 22, and simulate a single replicate. After
the simulation is completed, we plot histograms of the recombination
rates and the simulated breakpoints. These show that density of
breakpoints follows the recombination rate closely.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pyplot</span>

<span class="k">def</span> <span class="nf">variable_recomb_example</span><span class="p">():</span>
    <span class="n">infile</span> <span class="o">=</span> <span class="s2">&quot;hapmap/genetic_map_GRCh37_chr22.txt&quot;</span>
    <span class="c1"># Read in the recombination map using the read_hapmap method,</span>
    <span class="n">recomb_map</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">RecombinationMap</span><span class="o">.</span><span class="n">read_hapmap</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span>

    <span class="c1"># Now we get the positions and rates from the recombination</span>
    <span class="c1"># map and plot these using 500 bins.</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">recomb_map</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">recomb_map</span><span class="o">.</span><span class="n">get_rates</span><span class="p">()[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">num_bins</span> <span class="o">=</span> <span class="mi">500</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">binned_statistic</span><span class="p">(</span>
        <span class="n">positions</span><span class="p">,</span> <span class="n">rates</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">num_bins</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">))]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">))]</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">pyplot</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Recombination rate&quot;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Chromosome position&quot;</span><span class="p">)</span>

    <span class="c1"># Now we run the simulation for this map. We simulate</span>
    <span class="c1"># 50 diploids (100 sampled genomes) in a population with Ne=10^4.</span>
    <span class="n">tree_sequence</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
        <span class="n">sample_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">Ne</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">recombination_map</span><span class="o">=</span><span class="n">recomb_map</span><span class="p">)</span>
    <span class="c1"># Now plot the density of breakpoints along the chromosome</span>
    <span class="n">breakpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">breakpoints</span><span class="p">()))</span>
    <span class="n">ax2</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">breakpoints</span><span class="p">,</span> <span class="n">num_bins</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Breakpoint density&quot;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mf">1.5e7</span><span class="p">,</span> <span class="mf">5.3e7</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;hapmap_chr22.svg&quot;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/hapmap_chr22.svg"><img alt="Density of breakpoints along the chromosome." src="_images/hapmap_chr22.svg" width="800px" /></a>
</div>
<div class="section" id="multiple-chromosomes">
<span id="sec-tutorial-multiple-chromosomes"></span><h2>Multiple chromosomes<a class="headerlink" href="#multiple-chromosomes" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This approach is somewhat hacky; hopefully we will have a more
elegant solution soon!</p>
</div>
<p>Multiple chromosomes can be simulated by specifying a recombination map with
hotspots between chromosomes. For example, to simulate two chromosomes each 1
Morgan in length:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rho</span> <span class="o">=</span> <span class="mf">1e-8</span>
<span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1e8</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1e8</span><span class="p">,</span> <span class="mf">2e8</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">rates</span> <span class="o">=</span> <span class="p">[</span><span class="n">rho</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">num_loci</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="n">recombination_map</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">RecombinationMap</span><span class="p">(</span>
    <span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">rates</span><span class="o">=</span><span class="n">rates</span><span class="p">,</span> <span class="n">num_loci</span><span class="o">=</span><span class="n">num_loci</span><span class="p">)</span>

<span class="n">tree_sequence</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
    <span class="n">sample_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">recombination_map</span><span class="o">=</span><span class="n">recombination_map</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="s2">&quot;dtwf&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Care must be taken when simulating whole genomes this way, as the rescaling
required to model such large fluctuations in recombination rate can result in
the following error: <code class="docutils literal notranslate"><span class="pre">Bad</span> <span class="pre">edge</span> <span class="pre">interval</span> <span class="pre">where</span> <span class="pre">right</span> <span class="pre">&lt;=</span> <span class="pre">left</span></code></p>
<p>This can be avoided by discretizing the genome into 100bp chunks by changing
the above to:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rho</span> <span class="o">=</span> <span class="mf">1e-8</span>
<span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1e8</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1e8</span><span class="p">,</span> <span class="mf">2e8</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">rates</span> <span class="o">=</span> <span class="p">[</span><span class="n">rho</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">num_loci</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">100</span> <span class="c1"># Discretize into 100bp chunks</span>
</pre></div>
</div>
<p>Also note that recombinations will still occur in the gaps between chromosomes,
with corresponding trees in the tree sequence. This will be fixed in a future
release.</p>
</div>
<div class="section" id="hybrid-simulations">
<span id="sec-tutorial-hybrid-simulations"></span><h2>Hybrid simulations<a class="headerlink" href="#hybrid-simulations" title="Permalink to this headline">¶</a></h2>
<p>In some situations Wright-Fisher simulations are desireable but less
computationally efficient than coalescent simulations, for example simulating a
small sample in a recently admixed population. In these cases, a hybrid model
offers an excellent tradeoff between simulation accuracy and performance.</p>
<p>This is done through a <a class="reference internal" href="api.html#msprime.SimulationModelChange" title="msprime.SimulationModelChange"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationModelChange</span></code></a> event, which is a special type of
demographic event.</p>
<p>For example, here we switch from the discrete-time Wright-Fisher model to the
standard Hudson coalescent 500 generations in the past:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
    <span class="n">sample_size</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;dtwf&quot;</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">demographic_events</span><span class="o">=</span><span class="p">[</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">SimulationModelChange</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;hudson&quot;</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">id</span>      <span class="n">flags</span>   <span class="n">population</span>      <span class="n">individual</span>      <span class="n">time</span>    <span class="n">metadata</span>
<span class="mi">0</span>       <span class="mi">1</span>       <span class="mi">0</span>       <span class="o">-</span><span class="mi">1</span>      <span class="mf">0.00000000000000</span>
<span class="mi">1</span>       <span class="mi">1</span>       <span class="mi">0</span>       <span class="o">-</span><span class="mi">1</span>      <span class="mf">0.00000000000000</span>
<span class="mi">2</span>       <span class="mi">1</span>       <span class="mi">0</span>       <span class="o">-</span><span class="mi">1</span>      <span class="mf">0.00000000000000</span>
<span class="mi">3</span>       <span class="mi">1</span>       <span class="mi">0</span>       <span class="o">-</span><span class="mi">1</span>      <span class="mf">0.00000000000000</span>
<span class="mi">4</span>       <span class="mi">1</span>       <span class="mi">0</span>       <span class="o">-</span><span class="mi">1</span>      <span class="mf">0.00000000000000</span>
<span class="mi">5</span>       <span class="mi">1</span>       <span class="mi">0</span>       <span class="o">-</span><span class="mi">1</span>      <span class="mf">0.00000000000000</span>
<span class="mi">6</span>       <span class="mi">0</span>       <span class="mi">0</span>       <span class="o">-</span><span class="mi">1</span>      <span class="mf">78.00000000000000</span>
<span class="mi">7</span>       <span class="mi">0</span>       <span class="mi">0</span>       <span class="o">-</span><span class="mi">1</span>      <span class="mf">227.00000000000000</span>
<span class="mi">8</span>       <span class="mi">0</span>       <span class="mi">0</span>       <span class="o">-</span><span class="mi">1</span>      <span class="mf">261.00000000000000</span>
<span class="mi">9</span>       <span class="mi">0</span>       <span class="mi">0</span>       <span class="o">-</span><span class="mi">1</span>      <span class="mf">272.00000000000000</span>
<span class="mi">10</span>      <span class="mi">0</span>       <span class="mi">0</span>       <span class="o">-</span><span class="mi">1</span>      <span class="mf">1629.06982528980075</span>
</pre></div>
</div>
<p>Because of the integer node times, we can see here that most of the coalescent
happened during the Wright-Fisher phase of the simulation, and as-of 500
generations in the past, there were only two lineages left. The continuous
time standard coalescent model was then used to simulate the ancient past of
these two lineages.</p>
</div>
<div class="section" id="completing-forwards-simulations">
<span id="sec-tutorial-simulate-from"></span><h2>Completing forwards simulations<a class="headerlink" href="#completing-forwards-simulations" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">msprime</span></code> simulator generates tree sequences using the backwards in
time coalescent model. But it is also possible to output tree sequences
from <a class="reference external" href="https://www.biorxiv.org/content/early/2018/01/16/248500">forwards-time</a>
simulators such as <a class="reference external" href="https://messerlab.org/slim/">SLiM</a>.
There are many advantages to using forward-time simulators, but they
are usually quite slow compared to similar coalescent simulations. In this
section we show how to combine the best of both approaches by simulating
the recent past using a forwards-time simulator and then complete the
simulation of the ancient past using <code class="docutils literal notranslate"><span class="pre">msprime</span></code>. (We sometimes refer to this
“recapitation”, as we can think of it as adding a “head” onto a tree sequence.)</p>
<p>First, we define a simple Wright-Fisher simulator which returns a tree sequence
with the properties that we require (please see the <a class="reference internal" href="api.html#sec-api-simulate-from"><span class="std std-ref">API</span></a>
section for a formal description of these properties):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">wright_fisher</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulate a Wright-Fisher population of N haploid individuals with L</span>
<span class="sd">    discrete loci for T generations. Based on Algorithm W from</span>
<span class="sd">    https://www.biorxiv.org/content/biorxiv/early/2018/01/16/248500.full.pdf</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
    <span class="n">tables</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># Mark the initial generation as samples so that we remember these nodes.</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">msprime</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">T</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">Pp</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">Pp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">P</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">u</span><span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">P</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">Pp</span>

    <span class="c1"># Now do some table manipulations to ensure that the tree sequence</span>
    <span class="c1"># that we output has the form that msprime needs to finish the</span>
    <span class="c1"># simulation. Much of the complexity here is caused by the tables API</span>
    <span class="c1"># not allowing direct access to memory, which will change soon.</span>

    <span class="c1"># Mark the extant population as samples also</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flags</span>
    <span class="n">flags</span><span class="p">[</span><span class="n">P</span><span class="p">]</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="c1"># Simplify with respect to the current generation, but ensuring we keep the</span>
    <span class="c1"># ancient nodes from the initial population.</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
    <span class="c1"># Unmark the initial generation as samples</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flags</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">time</span>
    <span class="n">flags</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">flags</span><span class="p">[</span><span class="n">time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span>
    <span class="c1"># The final tables must also have at least one population which</span>
    <span class="c1"># the samples are assigned to</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">add_row</span><span class="p">()</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
        <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
        <span class="n">population</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">population</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
</pre></div>
</div>
<p>We then run a tiny forward simulation of 10 two-locus individuals
for 5 generations, and print out the resulting trees:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">num_loci</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">wf_ts</span> <span class="o">=</span> <span class="n">wright_fisher</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">num_loci</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">wf_ts</span><span class="o">.</span><span class="n">trees</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;interval = &quot;</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;unicode&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>We get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>interval =  (0.0, 1.0)
       0                 7
       ┃                 ┃
       25                ┃
  ┏━━━━┻━━━━┓            ┃
  23        24           ┃
┏━┻━┓    ┏━━╋━━━┓        ┃
┃   21   ┃  ┃   22       20
┃  ┏┻━┓  ┃  ┃  ┏┻━┓   ┏━━╋━━┓
10 14 19 11 18 15 17  12 13 16

interval =  (1.0, 2.0)
        0          8    4     7
        ┃          ┃   ┏┻━┓   ┃
        21         ┃   ┃  ┃   ┃
┏━━┳━━┳━┻┳━━┳━━┓   ┃   ┃  ┃   ┃
14 19 10 13 16 18  11  15 17  12
</pre></div>
</div>
<p>Because our Wright Fisher simulation ran for only 5 generations, there has not
been enough time for the trees to fully coalesce. Therefore, instead of having
one root, the trees have several — the first tree has 2 and the second 4.
Nodes 0 to 9 in this simulation represent the initial population of the
simulation, and so we can see that all samples in the first tree trace back
to one of two individuals from the initial generation.
These unary branches joining samples and coalesced subtrees to the nodes
in the initial generation are essential as they allow use to correctly
assemble the various fragments of ancestral material into chromosomes
when creating the initial conditions for the coalescent simulation.
(Please see the <a class="reference internal" href="api.html#sec-api-simulate-from"><span class="std std-ref">API</span></a> section for more details on the
required properties of input tree sequences.)</p>
<p>The process of completing this tree sequence using a coalescent simulation
begins by first examining the root segments on the input trees. We get the
following segments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
</pre></div>
</div>
<p>where each segment is a <code class="docutils literal notranslate"><span class="pre">(left,</span> <span class="pre">right,</span> <span class="pre">node)</span></code> tuple. As nodes 0 and 7 are
present in both trees, they have segments spanning both loci. Nodes 8 and 4 are
present only in the second tree, and so they have ancestral segments only for
the second locus. Note that this means that we do <em>not</em> simulate the ancestry
of the entire initial generation of the simulation, but rather the exact
minimum that we need in order to complete the ancestry of the current
generation. For instance, root <code class="docutils literal notranslate"><span class="pre">8</span></code> has not coalesced over the interval from
<code class="docutils literal notranslate"><span class="pre">1.0</span></code> to <code class="docutils literal notranslate"><span class="pre">2.0</span></code>, while root <code class="docutils literal notranslate"><span class="pre">0</span></code> has not coalesced over the entire segment
from <code class="docutils literal notranslate"><span class="pre">0.0</span></code> to <code class="docutils literal notranslate"><span class="pre">2.0</span></code>.</p>
<p>We run the coalescent simulation to complete this tree sequence using the
<code class="docutils literal notranslate"><span class="pre">from_ts</span></code> argument to <a class="reference internal" href="api.html#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>. Because we have simulated a
two locus system with a recombination rate of <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">num_loci</span></code> per generation
in the Wright-Fisher model, we want to use the same system in the coalescent simulation.
To do this we create recombination map using the
<a class="reference internal" href="api.html#msprime.RecombinationMap.uniform_map" title="msprime.RecombinationMap.uniform_map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">RecombinationMap.uniform_map()</span></code></a> class method to easily create a
discrete map with the required number of loci.
(Please see the <a class="reference internal" href="api.html#sec-api-simulate-from"><span class="std std-ref">API</span></a> section for more details on the
restrictions on recombination maps when completing an existing simulation.)
We also use a <code class="docutils literal notranslate"><span class="pre">Ne</span></code> value of <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">/</span> <span class="pre">2</span></code>
since the Wright-Fisher simulation was haploid and <code class="docutils literal notranslate"><span class="pre">msprime</span></code> is diploid.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">recomb_map</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">RecombinationMap</span><span class="o">.</span><span class="n">uniform_map</span><span class="p">(</span><span class="n">num_loci</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">num_loci</span><span class="p">,</span> <span class="n">num_loci</span><span class="p">)</span>
<span class="n">coalesced_ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
    <span class="n">Ne</span><span class="o">=</span><span class="n">N</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">from_ts</span><span class="o">=</span><span class="n">wf_ts</span><span class="p">,</span> <span class="n">recombination_map</span><span class="o">=</span><span class="n">recomb_map</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>After running this simulation we get the following trees:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>interval =  (0.0, 1.0)
                26
       ┏━━━━━━━━┻━━━━━━━┓
       0                7
       ┃                ┃
       25               ┃
  ┏━━━━┻━━━━┓           ┃
  23        24          ┃
┏━┻━┓    ┏━━╋━━━┓       ┃
┃   21   ┃  ┃   22      20
┃  ┏┻━┓  ┃  ┃  ┏┻━┓  ┏━━╋━━┓
10 14 19 11 18 15 17 12 13 16

interval =  (1.0, 2.0)
                  28
             ┏━━━━┻━━━━━┓
             ┃          27
             ┃        ┏━┻━━┓
             26       ┃    ┃
        ┏━━━━┻━━━━┓   ┃    ┃
        0         7   4    8
        ┃         ┃  ┏┻━┓  ┃
        21        ┃  ┃  ┃  ┃
┏━━┳━━┳━┻┳━━┳━━┓  ┃  ┃  ┃  ┃
14 19 10 13 16 18 12 15 17 11
</pre></div>
</div>
<p>The trees have fully coalesced and we’ve successfully combined a forwards-time
Wright-Fisher simulation with a coalescent simulation: hooray!</p>
<div class="section" id="why-record-the-initial-generation">
<h3>Why record the initial generation?<a class="headerlink" href="#why-record-the-initial-generation" title="Permalink to this headline">¶</a></h3>
<p>We can now see why it is essential that the forwards simulator records the
<em>initial</em> generation in a tree sequence that will later be used as a
<code class="docutils literal notranslate"><span class="pre">from_ts</span></code> argument to <a class="reference internal" href="api.html#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>. In the example above, if node
<code class="docutils literal notranslate"><span class="pre">7</span></code> was not in the tree sequence, we would not know that the segment that
node <code class="docutils literal notranslate"><span class="pre">20</span></code> inherits from on <code class="docutils literal notranslate"><span class="pre">[0.0,</span> <span class="pre">1.0)</span></code> and the segment that node <code class="docutils literal notranslate"><span class="pre">12</span></code>
inherits from on <code class="docutils literal notranslate"><span class="pre">[1.0,</span> <span class="pre">2.0)</span></code> both exist in the same node (here, node <code class="docutils literal notranslate"><span class="pre">7</span></code>).</p>
<p>However, note that although the intial generation (above, nodes <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">4</span></code>,
<code class="docutils literal notranslate"><span class="pre">7</span></code>, and <code class="docutils literal notranslate"><span class="pre">8</span></code>) must be in the tree sequence, they do <em>not</em> have to be
samples. The easiest way to do this is to
(a) retain the initial generation as samples throughout the forwards simulation
(so they persist through <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TableCollection.simplify" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">simplify()</span></code></a>), but then (b) before we output
the final tree sequence, we remove the flags that mark them as samples,
so that <a class="reference internal" href="api.html#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a> does not simulate their entire history as well. This
is the approach taken in the toy simulator provided above (although we skip
the periodic <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TableCollection.simplify" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">simplify()</span></code></a> steps which are essential in any practical simulation
for simplicity).</p>
</div>
<div class="section" id="topology-gotchas">
<h3>Topology gotchas<a class="headerlink" href="#topology-gotchas" title="Permalink to this headline">¶</a></h3>
<p>The trees that we output from this combined forwards and backwards simulation
process have some slightly odd properties that are important to be aware of.
In the example above, we can see that the old roots are still present in both trees,
even through they have only one child and are clearly redundant.
This is because the tables of <code class="docutils literal notranslate"><span class="pre">from_ts</span></code> have been retained, without modification,
at the top of the tables of the output tree sequence. While this
redundancy is not important for many tasks, there are some cases where
they may cause problems:</p>
<ol class="arabic simple">
<li><p>When computing statistics on the number of nodes, edges or trees in a tree
sequence, having these unary edges and redundant nodes will slightly
inflate the values.</p></li>
<li><p>If you are computing the overall tree “height” by taking the time of the
root node, you may overestimate the height because there is a unary edge
above the “real” root (this would happen if one of the trees had already
coalesced in the forwards-time simulation).</p></li>
</ol>
<p>For these reasons it is usually better to remove this redundancy from your
computed tree sequence which is easily done using the
<a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence.simplify" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tskit.TreeSequence.simplify()</span></code></a> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">final_ts</span> <span class="o">=</span> <span class="n">coalesced_ts</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">final_ts</span><span class="o">.</span><span class="n">trees</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;interval = &quot;</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;unicode&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>giving us:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>interval =  (0.0, 1.0)
      17
  ┏━━━┻━━━━┓
  ┃        15
  ┃     ┏━━┻━━┓
  ┃     13    14
  ┃   ┏━┻┓  ┏━╋━━┓
  10  ┃  11 ┃ ┃  12
┏━╋━┓ ┃ ┏┻┓ ┃ ┃ ┏┻┓
2 3 6 0 4 9 1 8 5 7

interval =  (1.0, 2.0)
          19
    ┏━━━━━┻━━━━━┓
    ┃           18
    ┃         ┏━┻┓
    17        ┃  ┃
┏━━━┻━━┓      ┃  ┃
┃      ┃      ┃  16
┃      ┃      ┃ ┏┻┓
┃      11     ┃ ┃ ┃
┃ ┏━┳━┳┻┳━┳━┓ ┃ ┃ ┃
2 4 9 0 3 6 8 1 5 7
</pre></div>
</div>
<p>This final tree sequence is topologically identical to the original tree sequence,
but has the redundant nodes and edges removed. Note also that he node IDs have been
reassigned so that the samples are 0 to 9 — if you need the IDs from the original
tree sequence, please set <code class="docutils literal notranslate"><span class="pre">map_nodes=True</span></code> when calling <code class="docutils literal notranslate"><span class="pre">simplify</span></code> to get a
mapping between the two sets of IDs.</p>
</div>
</div>
<div class="section" id="recording-the-full-arg">
<span id="sec-tutorial-record-full-arg"></span><h2>Recording the full ARG<a class="headerlink" href="#recording-the-full-arg" title="Permalink to this headline">¶</a></h2>
<p>In <code class="docutils literal notranslate"><span class="pre">msprime</span></code> we usually want to simulate the coalescent with recombination
and represent the output as efficiently as possible. As a result, we don’t
store individual recombination events, but rather their effects on the output
tree sequence. We also do not explicitly store common ancestor events that
do not result in marginal coalescences. For some purposes, however, we want
to get information on the full history of the simulation, not just the minimal
representation of its outcome. The <code class="docutils literal notranslate"><span class="pre">record_full_arg</span></code> option to
<a class="reference internal" href="api.html#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a> provides this functionality, as illustrated in the following
example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">full_arg_example</span><span class="p">():</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
        <span class="n">sample_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">record_full_arg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">trees</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;interval:&quot;</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;unicode&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>Running this code we get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>id      flags   population      individual      time    metadata
0       1       0       -1      0.00000000000000
1       1       0       -1      0.00000000000000
2       1       0       -1      0.00000000000000
3       1       0       -1      0.00000000000000
4       1       0       -1      0.00000000000000
5       0       0       -1      0.31846010419674
6       0       0       -1      0.82270149120229
7       0       0       -1      1.21622732856555
8       131072  0       -1      1.51542116580501
9       131072  0       -1      1.51542116580501
10      262144  0       -1      2.12814260094490
11      0       0       -1      2.16974122606933

interval: (0.0, 0.7323522972251177)
      11
   ┏━━┻━┓
   ┃    10
   ┃    ┃
   ┃    8
   ┃    ┃
   7    ┃
 ┏━┻━┓  ┃
 ┃   6  ┃
 ┃  ┏┻┓ ┃
 5  ┃ ┃ ┃
┏┻┓ ┃ ┃ ┃
0 4 2 3 1

interval: (0.7323522972251177, 1.0)
      11
   ┏━━┻━┓
   ┃    10
   ┃    ┃
   ┃    9
   ┃    ┃
   7    ┃
 ┏━┻━┓  ┃
 ┃   6  ┃
 ┃  ┏┻┓ ┃
 5  ┃ ┃ ┃
┏┻┓ ┃ ┃ ┃
0 4 2 3 1
</pre></div>
</div>
<p>After running the simulation we first print out the <a class="reference external" href="https://tskit.readthedocs.io/en/stable/data-model.html#node-table">node table</a>, which
contains information on all the nodes in the tree sequence. Note that <code class="docutils literal notranslate"><span class="pre">flags</span></code>
column contains several different values: all of the sample nodes (at time 0)
have a flag value of <code class="docutils literal notranslate"><span class="pre">1</span></code> (<a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.NODE_IS_SAMPLE" title="(in tskit v0.3)"><code class="xref py py-data docutils literal notranslate"><span class="pre">tskit.NODE_IS_SAMPLE</span></code></a>). Other internal
nodes have a flag value of <code class="docutils literal notranslate"><span class="pre">0</span></code>, which is the standard for internal nodes
in a coalescent simulations.</p>
<p>Nodes 8 and 9 have flags equal to 131072 (<a class="reference internal" href="api.html#msprime.NODE_IS_RE_EVENT" title="msprime.NODE_IS_RE_EVENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">NODE_IS_RE_EVENT</span></code></a>), which
tells us that they correspond to a recombination event in the ARG. A
recombination event results in two extra nodes being recorded, one identifying
the individual providing the genetic material to the left of the breakpoint and
the other identifying the individuals providing the genetic material to the
right. The effect of this extra node can be seen in the trees: node 8 is
present as a ‘unary’ node in the left hand tree and node 9 in the right.</p>
<p>Node 10 has a flags value of 262144 (<a class="reference internal" href="api.html#msprime.NODE_IS_CA_EVENT" title="msprime.NODE_IS_CA_EVENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">NODE_IS_CA_EVENT</span></code></a>), which
tells us that it is an ARG common ancestor event that <em>did not</em> result
in marginal coalescence. This class of event also results in unary nodes
in the trees, which we can see in the example.</p>
<p>If we wish to reduce these trees down to the minimal representation, we can
use <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence.simplify" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tskit.TreeSequence.simplify()</span></code></a>. The resulting tree sequence will have
all of these unary nodes removed and will be equivalent to (but not identical, due to
stochastic effects) calling <a class="reference internal" href="api.html#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a> without the <code class="docutils literal notranslate"><span class="pre">record_full_arg</span></code>
argument.</p>
<p>Migrations nodes are also recording in the ARG using the
<a class="reference internal" href="api.html#msprime.NODE_IS_MIG_EVENT" title="msprime.NODE_IS_MIG_EVENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">NODE_IS_MIG_EVENT</span></code></a> flag. See the <a class="reference internal" href="api.html#sec-api-node-flags"><span class="std std-ref">Node flags</span></a>
section for more details.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="api.html" class="btn btn-neutral float-right" title="API Documentation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="installation.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2015-2019, Jerome Kelleher.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>