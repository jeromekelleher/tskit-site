

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>API Documentation &mdash; msprime 0.7.5 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Command line interface" href="cli.html" />
    <link rel="prev" title="Tutorial" href="tutorial.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> msprime
          

          
          </a>

          
            
            
              <div class="version">
                0.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#simulation-model">Simulation model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-simulations">Running simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#population-structure">Population structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#demographic-events">Demographic Events</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#debugging-demographic-models">Debugging demographic models</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#variable-recombination-rates">Variable recombination rates</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simulation-models">Simulation models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#coalescent-and-approximations">Coalescent and approximations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#discrete-time-wright-fisher">Discrete time Wright-Fisher</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#initialising-simulations-from-a-tree-sequence">Initialising simulations from a tree sequence</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#input-requirements">Input requirements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#recombination-map-limitations">Recombination map limitations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#node-flags">Node flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simulating-mutations">Simulating mutations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="cli.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="CITATION.html">Citing msprime</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">msprime</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>API Documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api-documentation">
<span id="sec-api"></span><h1>API Documentation<a class="headerlink" href="#api-documentation" title="Permalink to this headline">¶</a></h1>
<p>This is the API documentation for <code class="docutils literal notranslate"><span class="pre">msprime</span></code>, and provides detailed information
on the Python programming interface. See the <a class="reference internal" href="tutorial.html#sec-tutorial"><span class="std std-ref">Tutorial</span></a> for an
introduction to using this API to run simulations.
See the <a class="reference external" href="https://tskit.readthedocs.io/en/stable">tskit documentation</a> for
information on how to use the
<a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html">tskit Python API</a>
to analyse simulation results.</p>
<div class="section" id="simulation-model">
<h2>Simulation model<a class="headerlink" href="#simulation-model" title="Permalink to this headline">¶</a></h2>
<p>The simulation model in <code class="docutils literal notranslate"><span class="pre">msprime</span></code> closely follows the classical <code class="docutils literal notranslate"><span class="pre">ms</span></code>
program. Unlike <code class="docutils literal notranslate"><span class="pre">ms</span></code>, however, time is measured in generations rather than
in units of <span class="math notranslate nohighlight">\(4 N_e\)</span> generations, i.e., “coalescent units”.
This means that when simulating a population with diploid effective size <span class="math notranslate nohighlight">\(N_e\)</span>,
the mean time to coalescence between two samples
in an <code class="docutils literal notranslate"><span class="pre">msprime</span></code> simulation will be around <span class="math notranslate nohighlight">\(2 N_e\)</span>,
while in an <code class="docutils literal notranslate"><span class="pre">ms</span></code> simulation, the mean time will be around <span class="math notranslate nohighlight">\(0.5\)</span>.
Internally, <code class="docutils literal notranslate"><span class="pre">msprime</span></code> uses the same algorithm as <code class="docutils literal notranslate"><span class="pre">ms</span></code>,
and so the <code class="docutils literal notranslate"><span class="pre">Ne</span></code> parameter to the <a class="reference internal" href="#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a> function
still acts as a time scaling, and can be set to <code class="docutils literal notranslate"><span class="pre">0.5</span></code> to match many theoretical results,
or to <code class="docutils literal notranslate"><span class="pre">0.25</span></code> to match <code class="docutils literal notranslate"><span class="pre">ms</span></code>. Population sizes for each
subpopulation and for past demographic events are also defined as absolute values, <strong>not</strong>
scaled by <code class="docutils literal notranslate"><span class="pre">Ne</span></code>. All migration rates and growth rates are also per generation.</p>
<p>When running simulations we define the length <span class="math notranslate nohighlight">\(L\)</span> of the sequence in
question using the <code class="docutils literal notranslate"><span class="pre">length</span></code> parameter. This defines the coordinate space
within which trees and mutations are defined. <span class="math notranslate nohighlight">\(L\)</span> is a continuous value,
so units are arbitrary, and coordinates can take any continuous value from <span class="math notranslate nohighlight">\(0\)</span> up to
(but not including) <span class="math notranslate nohighlight">\(L\)</span>. (So, although we recommend setting the units of length to be
analogous to “bases”, events can occur at fractional positions.)
Mutations occur in an infinite sites process along this sequence,
and mutation rates are specified per generation, per unit of sequence length.
Thus, given the per-generation mutation rate <span class="math notranslate nohighlight">\(\mu\)</span>, the rate of mutation
over the entire sequence in coalescent time units is <span class="math notranslate nohighlight">\(\theta = 4 N_e \mu
L\)</span>. It is important to remember these scaling factors when comparing with
analytical results!</p>
<p>Similarly, recombination rates are per unit of sequence length and per
generation in <code class="docutils literal notranslate"><span class="pre">msprime</span></code>. Thus, given the per generation crossover rate
<span class="math notranslate nohighlight">\(r\)</span>, the overall rate of recombination between the ends of the sequence
in coalescent time units is <span class="math notranslate nohighlight">\(\rho = 4 N_e r L\)</span>. Although breakpoints do
not necessarily occur at integer locations, the underlying recombination model
is finite, and the behaviour of a small number of loci can be modelled using
the <a class="reference internal" href="#msprime.RecombinationMap" title="msprime.RecombinationMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecombinationMap</span></code></a> class. However, this is considered an advanced
feature and the majority of cases should be well served with the default
recombination model and number of loci.</p>
<p>Population structure is modelled by specifying a fixed number of subpopulations
<span class="math notranslate nohighlight">\(d\)</span>, and a <span class="math notranslate nohighlight">\(d \times d\)</span> matrix <span class="math notranslate nohighlight">\(M\)</span> of per generation
migration rates. Each element of the matrix <span class="math notranslate nohighlight">\(M_{j,k}\)</span> defines
the fraction of population <span class="math notranslate nohighlight">\(j\)</span> that consists of migrants from
population <span class="math notranslate nohighlight">\(k\)</span> in each generation.
Each subpopulation has an initial absolute population size <span class="math notranslate nohighlight">\(s\)</span>
and a per generation exponential growth rate <span class="math notranslate nohighlight">\(\alpha\)</span>. The size of a
given population at time <span class="math notranslate nohighlight">\(t\)</span> in the past (measured in generations) is
therefore given by <span class="math notranslate nohighlight">\(s e^{-\alpha t}\)</span>. Demographic events that occur in
the history of the simulated population alter some aspect of this population
configuration at a particular time in the past.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This parameterisation of recombination, mutation and
migration rates is different to <strong class="program">ms</strong>, which states these
rates over the entire region and in coalescent time units. The
motivation for this is to allow the user change the size of the simulated
region without having to rescale the recombination and mutation rates,
and to also allow users directly state times and rates in units of
generations. However, the <code class="docutils literal notranslate"><span class="pre">mspms</span></code> command line application is
fully <strong class="program">ms</strong> compatible.</p>
</div>
</div>
<div class="section" id="running-simulations">
<h2>Running simulations<a class="headerlink" href="#running-simulations" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a> function provides the primary interface to running
coalescent simulations in msprime.</p>
<dl class="py function">
<dt id="msprime.simulate">
<code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">simulate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#msprime.simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulates the coalescent with recombination under the specified model
parameters and returns the resulting <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.TreeSequence</span></code></a>. Note that
Ne is the effective diploid population size (so the effective number
of genomes in the population is 2*Ne), but <code class="docutils literal notranslate"><span class="pre">sample_size</span></code> is the
number of (monoploid) genomes sampled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The number of sampled monoploid genomes.  If not
specified or None, this defaults to the sum of the subpopulation sample
sizes. Either <code class="docutils literal notranslate"><span class="pre">sample_size</span></code>, <code class="docutils literal notranslate"><span class="pre">population_configurations</span></code> or
<code class="docutils literal notranslate"><span class="pre">samples</span></code> must be specified.</p></li>
<li><p><strong>Ne</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The effective (diploid) population size for the reference
population. This defaults to 1 if not specified.</p></li>
<li><p><strong>length</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The length of the simulated region in bases.
This parameter cannot be used along with <code class="docutils literal notranslate"><span class="pre">recombination_map</span></code>.
Defaults to 1 if not specified.</p></li>
<li><p><strong>recombination_rate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The rate of recombination per base
per generation. This parameter cannot be used along with
<code class="docutils literal notranslate"><span class="pre">recombination_map</span></code>. Defaults to 0 if not specified.</p></li>
<li><p><strong>recombination_map</strong> (<a class="reference internal" href="#msprime.RecombinationMap" title="msprime.RecombinationMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecombinationMap</span></code></a>) – The map
describing the changing rates of recombination along the simulated
chromosome. This parameter cannot be used along with the
<code class="docutils literal notranslate"><span class="pre">recombination_rate</span></code> or <code class="docutils literal notranslate"><span class="pre">length</span></code> parameters, as these
values are encoded within the map. Defaults to a uniform rate as
described in the <code class="docutils literal notranslate"><span class="pre">recombination_rate</span></code> parameter if not specified.</p></li>
<li><p><strong>mutation_rate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The rate of infinite sites
mutations per unit of sequence length per generation.
If not specified, no mutations are generated. This option only
allows for infinite sites mutations with a binary (i.e., 0/1)
alphabet. For more control over the mutational process, please
use the <a class="reference internal" href="#msprime.mutate" title="msprime.mutate"><code class="xref py py-func docutils literal notranslate"><span class="pre">mutate()</span></code></a> function.</p></li>
<li><p><strong>population_configurations</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a><em> or </em><em>None.</em>) – The list of
<a class="reference internal" href="#msprime.PopulationConfiguration" title="msprime.PopulationConfiguration"><code class="xref py py-class docutils literal notranslate"><span class="pre">PopulationConfiguration</span></code></a> instances describing the
sampling configuration, relative sizes and growth rates of
the populations to be simulated. If this is not specified,
a single population with a sample of size <code class="docutils literal notranslate"><span class="pre">sample_size</span></code>
is assumed.</p></li>
<li><p><strong>migration_matrix</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a>) – The matrix describing the rates
of migration between all pairs of populations. If <span class="math notranslate nohighlight">\(N\)</span>
populations are defined in the <code class="docutils literal notranslate"><span class="pre">population_configurations</span></code>
parameter, then the migration matrix must be an
<span class="math notranslate nohighlight">\(N \times N\)</span> matrix with 0 on the diagonal, consisting of
<span class="math notranslate nohighlight">\(N\)</span> lists of length <span class="math notranslate nohighlight">\(N\)</span> or an <span class="math notranslate nohighlight">\(N \times N\)</span> numpy
array, with the [j, k]th element giving the fraction of
population j that consists of migrants from population k in each
generation.</p></li>
<li><p><strong>demographic_events</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a>) – The list of demographic events to
simulate. Demographic events describe changes to the populations
in the past. Events should be supplied in non-decreasing
order of time in the past. Events with the same time value will be
applied sequentially in the order that they were supplied before the
simulation algorithm continues with the next time step.</p></li>
<li><p><strong>samples</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a>) – The list specifying the location and time of
all samples. This parameter may be used to specify historical
samples, and cannot be used in conjunction with the <code class="docutils literal notranslate"><span class="pre">sample_size</span></code>
parameter. Each sample is a (<code class="docutils literal notranslate"><span class="pre">population</span></code>, <code class="docutils literal notranslate"><span class="pre">time</span></code>) pair
such that the sample in position <code class="docutils literal notranslate"><span class="pre">j</span></code> in the list of samples
is drawn in the specified population at the specfied time. Time
is measured in generations ago, as elsewhere.</p></li>
<li><p><strong>random_seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The random seed. If this is <cite>None</cite>, a
random seed will be automatically generated. Valid random
seeds must be between 1 and <span class="math notranslate nohighlight">\(2^{32} - 1\)</span>.</p></li>
<li><p><strong>num_replicates</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The number of replicates of the specified
parameters to simulate. If this is not specified or None,
no replication is performed and a <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.TreeSequence</span></code></a> object
returned. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_replicates</span></code> is provided, the specified
number of replicates is performed, and an iterator over the
resulting <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.TreeSequence</span></code></a> objects returned.</p></li>
<li><p><strong>from_ts</strong> (<a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><em>tskit.TreeSequence</em></a>) – If specified, initialise the simulation
from the root segments of this tree sequence and return the
completed tree sequence. Please see <a class="reference internal" href="#sec-api-simulate-from"><span class="std std-ref">here</span></a> for details on the required properties
of this tree sequence and its interactions with other parameters.
(Default: None).</p></li>
<li><p><strong>start_time</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – If specified, set the initial time that the
simulation starts to this value. If not specified, the start
time is zero if performing a simulation of a set of samples,
or is the time of the oldest node if simulating from an
existing tree sequence (see the <code class="docutils literal notranslate"><span class="pre">from_ts</span></code> parameter).</p></li>
<li><p><strong>end_time</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – If specified, terminate the simulation at the
specified time. In the returned tree sequence, all rootward paths from
samples with time &lt; end_time will end in a node with one child with
time equal to end_time. Sample nodes with time &gt;= end_time will
also be present in the output tree sequence. If not specified or <code class="docutils literal notranslate"><span class="pre">None</span></code>,
run the simulation until all samples have an MRCA at all positions in
the genome.</p></li>
<li><p><strong>record_full_arg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a>) – If True, record all intermediate nodes
arising from common ancestor and recombination events in the output
tree sequence. This will result in unary nodes (i.e., nodes in marginal
trees that have only one child). Defaults to False.</p></li>
<li><p><strong>model</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)"><em>str</em></a><em> or </em><em>simulation model instance</em>) – The simulation model to use.
This can either be a string (e.g., <code class="docutils literal notranslate"><span class="pre">&quot;smc_prime&quot;</span></code>) or an instance of
a simulation model class (e.g, <code class="docutils literal notranslate"><span class="pre">msprime.DiscreteTimeWrightFisher(100)</span></code>.
Please see the <a class="reference internal" href="#sec-api-simulation-models"><span class="std std-ref">Simulation models</span></a> section for more details
on specifying simulations models.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.TreeSequence</span></code></a> object representing the results
of the simulation if no replication is performed, or an
iterator over the independent replicates simulated if the
<code class="xref py py-obj docutils literal notranslate"><span class="pre">num_replicates</span></code> parameter has been used.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.TreeSequence</span></code></a> or an iterator over
<a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.TreeSequence</span></code></a> replicates.</p>
</dd>
<dt class="field-even">Warning</dt>
<dd class="field-even"><p>If using replication, do not store the results of the
iterator in a list! For performance reasons, the same
underlying object may be used for every TreeSequence
returned which will most likely lead to unexpected behaviour.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="population-structure">
<h2>Population structure<a class="headerlink" href="#population-structure" title="Permalink to this headline">¶</a></h2>
<p>Population structure is modelled in <code class="docutils literal notranslate"><span class="pre">msprime</span></code> by specifying a fixed number of
subpopulations, with the migration rates between those subpopulations defined by a migration
matrix. Each subpopulation has an <code class="docutils literal notranslate"><span class="pre">initial_size</span></code> that defines its absolute diploid size at
time zero and a per-generation <code class="docutils literal notranslate"><span class="pre">growth_rate</span></code> which specifies the exponential
growth rate of the sub-population. We must also define the number of genomes to
sample from each subpopulation. The number of populations and their initial
configuration is defined using the <code class="docutils literal notranslate"><span class="pre">population_configurations</span></code> parameter to
<a class="reference internal" href="#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>, which takes a list of <a class="reference internal" href="#msprime.PopulationConfiguration" title="msprime.PopulationConfiguration"><code class="xref py py-class docutils literal notranslate"><span class="pre">PopulationConfiguration</span></code></a>
instances. Population IDs are zero indexed, and correspond to their position in
the list.</p>
<p>Samples are drawn sequentially from populations in increasing order of
population ID. For example, if we specified an overall sample size of 6, and
specify that 2 samples are drawn from population 0 and 4 from population 1,
then samples 0 and 1 will be initially located in population 0, and
samples 2, 3, 4, and 5 will be drawn from population 2.</p>
<p>Given <span class="math notranslate nohighlight">\(N\)</span> populations, migration matrices are specified using an <span class="math notranslate nohighlight">\(N
\times N\)</span> matrix of between-subpopulation migration rates. See the
documentation for <a class="reference internal" href="#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a> and the <a class="reference internal" href="#simulation-model">Simulation model</a> section for
more details on the migration rates.</p>
<dl class="py class">
<dt id="msprime.PopulationConfiguration">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">PopulationConfiguration</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sample_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">growth_rate</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">metadata</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.PopulationConfiguration" title="Permalink to this definition">¶</a></dt>
<dd><p>The initial configuration of a population (or deme) in a simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The number of initial samples that are drawn
from this population.</p></li>
<li><p><strong>initial_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The absolute size of the population at time
zero. Defaults to the reference population size <span class="math notranslate nohighlight">\(N_e\)</span>.</p></li>
<li><p><strong>growth_rate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The forwards-time exponential growth rate of the
population per generation. Growth rates can be negative. This is zero for a
constant population size, and positive for a population that has been
growing. Defaults to 0.</p></li>
<li><p><strong>metadata</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><em>dict</em></a>) – A JSON-encodable dictionary of metadata to associate
with the corresponding Population in the output tree sequence.
If not specified or None, no metadata is stored (i.e., an empty bytes array).
Note that this metadata is ignored when using the <code class="docutils literal notranslate"><span class="pre">from_ts</span></code> argument to
<a class="reference internal" href="#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>, as the population definitions in the tree sequence that
is used as the starting point take precedence.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="demographic-events">
<span id="sec-api-demographic-events"></span><h2>Demographic Events<a class="headerlink" href="#demographic-events" title="Permalink to this headline">¶</a></h2>
<p>Demographic events change some aspect of the population configuration
at some time in the past, and are specified using the <code class="docutils literal notranslate"><span class="pre">demographic_events</span></code>
parameter to <a class="reference internal" href="#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>. Each element of this list must be an
instance of one of the following demographic events
that are currently supported. Note that all times are measured in
generations, all sizes are absolute (i.e., <em>not</em> relative to <span class="math notranslate nohighlight">\(N_e\)</span>),
and all rates are per-generation.</p>
<dl class="py class">
<dt id="msprime.PopulationParametersChange">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">PopulationParametersChange</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">initial_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">growth_rate</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">population</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">population_id</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.PopulationParametersChange" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the demographic parameters of a population at a given time.</p>
<p>This event generalises the <code class="docutils literal notranslate"><span class="pre">-eg</span></code>, <code class="docutils literal notranslate"><span class="pre">-eG</span></code>, <code class="docutils literal notranslate"><span class="pre">-en</span></code> and <code class="docutils literal notranslate"><span class="pre">-eN</span></code>
options from <code class="docutils literal notranslate"><span class="pre">ms</span></code>. Note that unlike <code class="docutils literal notranslate"><span class="pre">ms</span></code> we do not automatically
set growth rates to zero when the population size is changed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The length of time ago at which this event
occurred.</p></li>
<li><p><strong>initial_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The absolute diploid size of the population
at the beginning of the time slice starting at <code class="docutils literal notranslate"><span class="pre">time</span></code>. If None,
this is calculated according to the initial population size and
growth rate over the preceding time slice.</p></li>
<li><p><strong>growth_rate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The new per-generation growth rate. If None,
the growth rate is not changed. Defaults to None.</p></li>
<li><p><strong>population</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The ID of the population affected. If
<code class="docutils literal notranslate"><span class="pre">population</span></code> is None, the changes affect all populations
simultaneously.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="msprime.MigrationRateChange">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">MigrationRateChange</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">rate</span></em>, <em class="sig-param"><span class="n">matrix_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.MigrationRateChange" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the rate of migration to a new value at a specific time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The time at which this event occurs in generations.</p></li>
<li><p><strong>rate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The new per-generation migration rate.</p></li>
<li><p><strong>matrix_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.9)"><em>tuple</em></a>) – A tuple of two population IDs descibing
the matrix index of interest. If <code class="docutils literal notranslate"><span class="pre">matrix_index</span></code> is None, all
non-diagonal entries of the migration matrix are changed
simultaneously.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="msprime.MassMigration">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">MassMigration</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">source</span></em>, <em class="sig-param"><span class="n">dest</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">proportion</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">destination</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.MassMigration" title="Permalink to this definition">¶</a></dt>
<dd><p>A mass migration event in which some fraction of the population in
one deme simultaneously move to another deme, viewed backwards in
time. Each lineage currently present in the source population
moves to the destination population (backwards in time) with
probability equal to <code class="docutils literal notranslate"><span class="pre">proportion</span></code>.</p>
<p>This event class generalises the population split (<code class="docutils literal notranslate"><span class="pre">-ej</span></code>) and
admixture (<code class="docutils literal notranslate"><span class="pre">-es</span></code>) events from <code class="docutils literal notranslate"><span class="pre">ms</span></code>. Note that MassMigrations
do <em>not</em> have any side effects on the migration matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The time at which this event occurs in generations.</p></li>
<li><p><strong>source</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The ID of the source population.</p></li>
<li><p><strong>dest</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The ID of the destination population.</p></li>
<li><p><strong>proportion</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The probability that any given lineage within
the source population migrates to the destination population.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="msprime.SimulationModelChange">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">SimulationModelChange</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">model</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.SimulationModelChange" title="Permalink to this definition">¶</a></dt>
<dd><p>An event representing a change of underlying <a class="reference internal" href="#sec-api-simulation-models"><span class="std std-ref">simulation model</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The time at which the simulation model changes
to the new model, in generations. After this time, all internal
tree nodes, edges and migrations are the result of the new model.</p></li>
<li><p><strong>model</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)"><em>str</em></a><em> or </em><em>simulation model instance</em>) – The new simulation model to use.
This can either be a string (e.g., <code class="docutils literal notranslate"><span class="pre">&quot;smc_prime&quot;</span></code>) or an instance of
a simulation model class (e.g, <code class="docutils literal notranslate"><span class="pre">msprime.DiscreteTimeWrightFisher(100)</span></code>.
Please see the <a class="reference internal" href="#sec-api-simulation-models"><span class="std std-ref">Simulation models</span></a> section for more details
on specifying simulations models. If the argument is a string, the
reference population size is set from the top level <code class="docutils literal notranslate"><span class="pre">Ne</span></code> parameter
to <a class="reference internal" href="#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>. If this is None (the default) we revert to
the standard coalescent with the reference population size set by <code class="docutils literal notranslate"><span class="pre">Ne</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<span class="target" id="sec-api-demographic-events-census"></span><dl class="py class">
<dt id="msprime.CensusEvent">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">CensusEvent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.CensusEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>An event that adds a node to each branch of every tree at a given time
during the simulation. This may be used to record all ancestral haplotypes
present at that time, and to extract other information related to these
haplotypes: for instance to trace the local ancestry of a sample back to a
set of contemporaneous ancestors, or to assess whether a subset of samples
has coalesced more recently than the census time.
See the <a class="reference internal" href="tutorial.html#sec-tutorial-demography-census"><span class="std std-ref">tutorial</span></a> for an example.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The time at which this event occurs in generations.</p>
</dd>
</dl>
</dd></dl>

<div class="section" id="debugging-demographic-models">
<h3>Debugging demographic models<a class="headerlink" href="#debugging-demographic-models" title="Permalink to this headline">¶</a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DemographyDebugger</span></code> class is preliminary, and the API
is likely to change in the future.</p>
</div>
<dl class="py class">
<dt id="msprime.DemographyDebugger">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">DemographyDebugger</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Ne</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">population_configurations</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">migration_matrix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">demographic_events</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">model</span><span class="o">=</span><span class="default_value">'hudson'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.DemographyDebugger" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to facilitate debugging of population parameters and migration
rates in the past.</p>
<dl class="py method">
<dt id="msprime.DemographyDebugger.coalescence_rate_trajectory">
<code class="sig-name descname">coalescence_rate_trajectory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">steps</span></em>, <em class="sig-param"><span class="n">num_samples</span></em>, <em class="sig-param"><span class="n">min_pop_size</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">double_step_validation</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.DemographyDebugger.coalescence_rate_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will calculate the mean coalescence rates and proportions
of uncoalesced lineages between the lineages of the sample
configuration provided in <cite>num_samples</cite>, at each of the times ago
listed by steps, in this demographic model. The coalescence rate at
time t in the past is the average rate of coalescence of
as-yet-uncoalesed lineages, computed as follows: let <span class="math notranslate nohighlight">\(p(t)\)</span> be
the probability that the lineages of a randomly chosen pair of samples
has not yet coalesced by time <span class="math notranslate nohighlight">\(t\)</span>, let <span class="math notranslate nohighlight">\(p(z,t)\)</span> be the
probability that the lineages of a randomly chosen pair of samples has
not yet coalesced by time <span class="math notranslate nohighlight">\(t\)</span> <em>and</em> are both in population
<span class="math notranslate nohighlight">\(z\)</span>, and let <span class="math notranslate nohighlight">\(N(z,t)\)</span> be the diploid effective population
size of population <span class="math notranslate nohighlight">\(z\)</span> at time <span class="math notranslate nohighlight">\(t\)</span>. Then the mean
coalescence rate at time <span class="math notranslate nohighlight">\(t\)</span> is <span class="math notranslate nohighlight">\(r(t) = (\sum_z p(z,t) /
(2 * N(z,t)) / p(t)\)</span>.</p>
<p>The computation is done by approximating population size trajectories
with piecewise constant trajectories between each of the steps. For
this to be accurate, the distance between the steps must be small
enough so that (a) short epochs (e.g., bottlenecks) are not missed, and
(b) populations do not change in size too much over that time, if they
are growing or shrinking. This function optionally provides a simple
check of this approximation by recomputing the coalescence rates on a
grid of steps twice as fine and throwing a warning if the resulting
values do not match to a relative tolerance of 0.001.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>steps</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a>) – The times ago at which coalescence rates will be computed.</p></li>
<li><p><strong>num_samples</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a>) – A list of the same length as the number
of populations, so that <cite>num_samples[j]</cite> is the number of sampled
chromosomes in subpopulation <cite>j</cite>.</p></li>
<li><p><strong>min_pop_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The smallest allowed population size during
computation of coalescent rates (i.e., coalescence rates are actually
1 / (2 * max(min_pop_size, N(z,t))). Spurious very small population sizes
can occur in models where populations grow exponentially but are unused
before some time in the past, and lead to floating point error.
This should be set to a value smaller than the smallest
desired population size in the model.</p></li>
<li><p><strong>double_step_validation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a>) – Whether to perform the check that
step sizes are sufficiently small, as described above. This is highly
recommended, and will take at most four times the computation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tuple of arrays whose jth elements, respectively, are the
coalescence rate at the jth time point (denoted r(t[j]) above),
and the probablility that a randomly chosen pair of lineages has
not yet coalesced (denoted p(t[j]) above).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(numpy.array, numpy.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="msprime.DemographyDebugger.epoch_times">
<em class="property">property </em><code class="sig-name descname">epoch_times</code><a class="headerlink" href="#msprime.DemographyDebugger.epoch_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns array of epoch times defined by the demographic model</p>
</dd></dl>

<dl class="py method">
<dt id="msprime.DemographyDebugger.mean_coalescence_time">
<code class="sig-name descname">mean_coalescence_time</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_samples</span></em>, <em class="sig-param"><span class="n">min_pop_size</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">steps</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rtol</span><span class="o">=</span><span class="default_value">0.005</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">12</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.DemographyDebugger.mean_coalescence_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean time until coalescence between lineages of two samples drawn
from the sample configuration specified in <cite>num_samples</cite>. This is done using
<a class="reference internal" href="#msprime.DemographyDebugger.coalescence_rate_trajectory" title="msprime.DemographyDebugger.coalescence_rate_trajectory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coalescence_rate_trajectory</span></code></a>
to compute the probability that the lineages have not yet coalesced by time <cite>t</cite>,
and using these to approximate <span class="math notranslate nohighlight">\(E[T] = \int_t^\infty P(T &gt; t) dt\)</span>,
where <span class="math notranslate nohighlight">\(T\)</span> is the coalescence time. See
<a class="reference internal" href="#msprime.DemographyDebugger.coalescence_rate_trajectory" title="msprime.DemographyDebugger.coalescence_rate_trajectory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coalescence_rate_trajectory</span></code></a>
for more details.</p>
<p>To compute this, an adequate time discretization must be arrived at
by iteratively extending or refining the current discretization.
Debugging information about numerical convergence of this procedure is
logged using the Python <a class="reference external" href="https://docs.python.org/3/library/logging.html#module-logging" title="(in Python v3.9)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> infrastructure. To make it appear, using
the <code class="xref py py-mod docutils literal notranslate"><span class="pre">daiquiri</span></code> module, do for instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">daiquiri</span>

<span class="n">daiquiri</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s2">&quot;DEBUG&quot;</span><span class="p">)</span>
<span class="n">debugger</span><span class="o">.</span><span class="n">mean_coalescence_time</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>will print this debugging information to stderr. Briefly, this outputs
iteration number, mean coalescence time, maximum difference in probabilty
of not having coalesced yet, difference to last coalescence time,
probability of not having coalesced by the final time point, and
whether the last iteration was an extension or refinement.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_samples</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a>) – A list of the same length as the number
of populations, so that <cite>num_samples[j]</cite> is the number of sampled
chromosomes in subpopulation <cite>j</cite>.</p></li>
<li><p><strong>min_pop_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – See <a class="reference internal" href="#msprime.DemographyDebugger.coalescence_rate_trajectory" title="msprime.DemographyDebugger.coalescence_rate_trajectory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coalescence_rate_trajectory</span></code></a>.</p></li>
<li><p><strong>steps</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a>) – The time discretization to start out with (by default,
picks something based on epoch times).</p></li>
<li><p><strong>rtol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The relative tolerance to determine mean coalescence time
to (used to decide when to stop subdividing the steps).</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The maximum number of times to subdivide the steps.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mean coalescence time (a number).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="msprime.DemographyDebugger.num_epochs">
<em class="property">property </em><code class="sig-name descname">num_epochs</code><a class="headerlink" href="#msprime.DemographyDebugger.num_epochs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of epochs defined by the demographic model.</p>
</dd></dl>

<dl class="py method">
<dt id="msprime.DemographyDebugger.population_size_history">
<em class="property">property </em><code class="sig-name descname">population_size_history</code><a class="headerlink" href="#msprime.DemographyDebugger.population_size_history" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a (num_pops, num_epochs) numpy array giving the starting population size
for each population in each epoch.</p>
</dd></dl>

<dl class="py method">
<dt id="msprime.DemographyDebugger.population_size_trajectory">
<code class="sig-name descname">population_size_trajectory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">steps</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.DemographyDebugger.population_size_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns an array of per-population effective population sizes,
as defined by the demographic model. These are the <cite>initial_size</cite>
parameters of the model, modified by any population growth rates.
The sizes are computed at the time points given by <cite>steps</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>steps</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a>) – List of times ago at which the population
size will be computed.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns a numpy array of population sizes, with one column per
population, whose [i,j]th entry is the size of population
j at time steps[i] ago.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="msprime.DemographyDebugger.print_history">
<code class="sig-name descname">print_history</code><span class="sig-paren">(</span><em class="sig-param">output=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='utf-8'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.DemographyDebugger.print_history" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints a summary of the history of the populations.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="variable-recombination-rates">
<h2>Variable recombination rates<a class="headerlink" href="#variable-recombination-rates" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="msprime.RecombinationMap">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">RecombinationMap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">positions</span></em>, <em class="sig-param"><span class="n">rates</span></em>, <em class="sig-param"><span class="n">num_loci</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.RecombinationMap" title="Permalink to this definition">¶</a></dt>
<dd><p>A RecombinationMap represents the changing rates of recombination
along a chromosome. This is defined via two lists of numbers:
<code class="docutils literal notranslate"><span class="pre">positions</span></code> and <code class="docutils literal notranslate"><span class="pre">rates</span></code>, which must be of the same length.
Given an index j in these lists, the rate of recombination
per base per generation is <code class="docutils literal notranslate"><span class="pre">rates[j]</span></code> over the interval
<code class="docutils literal notranslate"><span class="pre">positions[j]</span></code> to <code class="docutils literal notranslate"><span class="pre">positions[j</span> <span class="pre">+</span> <span class="pre">1]</span></code>. Consequently, the first
position must be zero, and by convention the last rate value
is also required to be zero (although it is not used).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The chromosome is divided into <code class="docutils literal notranslate"><span class="pre">num_loci</span></code> regions of equal
<em>recombination</em> distance, between which recombinations occur.  This
means that if recombination is constant and the genome is length <code class="docutils literal notranslate"><span class="pre">n</span></code>,
then <code class="docutils literal notranslate"><span class="pre">num_loci=n</span></code> will produce breakpoints only at integer values. If
recombination rate is <em>not</em> constant, breakpoints will still only occur
at <code class="docutils literal notranslate"><span class="pre">n</span></code> distinct positions, but these will probably not coincide with
the <code class="docutils literal notranslate"><span class="pre">positions</span></code> provided.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>positions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a>) – The positions (in bases) denoting the
distinct intervals where recombination rates change. These can
be floating point values.</p></li>
<li><p><strong>rates</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a>) – The list of rates corresponding to the supplied
<code class="docutils literal notranslate"><span class="pre">positions</span></code>. Recombination rates are specified per base,
per generation.</p></li>
<li><p><strong>num_loci</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The maximum number of non-recombining loci
in the underlying simulation. By default this is set to
the largest possible value, allowing the maximum resolution
in the recombination process. However, for a finite sites
model this can be set to smaller values.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="msprime.RecombinationMap.DEFAULT_NUM_LOCI">
<code class="sig-name descname">DEFAULT_NUM_LOCI</code><em class="property"> = 4294967295</em><a class="headerlink" href="#msprime.RecombinationMap.DEFAULT_NUM_LOCI" title="Permalink to this definition">¶</a></dt>
<dd><p>The default number of non-recombining loci in a RecombinationMap.</p>
</dd></dl>

<dl class="py method">
<dt id="msprime.RecombinationMap.mean_recombination_rate">
<em class="property">property </em><code class="sig-name descname">mean_recombination_rate</code><a class="headerlink" href="#msprime.RecombinationMap.mean_recombination_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the weighted mean recombination rate
across all windows of the entire recombination map.</p>
</dd></dl>

<dl class="py method">
<dt id="msprime.RecombinationMap.read_hapmap">
<em class="property">classmethod </em><code class="sig-name descname">read_hapmap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.RecombinationMap.read_hapmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses the specified file in HapMap format. These files must be
white-space-delimited, and contain a single header line (which is
ignored), and then each subsequent line contains the starting position
and recombination rate for the segment from that position (inclusive)
to the starting position on the next line (exclusive). Starting
positions of each segment are given in units of bases, and
recombination rates in centimorgans/Megabase. The first column in this
file is ignored, as are additional columns after the third (Position is
assumed to be the second column, and Rate is assumed to be the third).
If the first starting position is not equal to zero, then a
zero-recombination region is inserted at the start of the chromosome.</p>
<p>A sample of this format is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Chromosome</span>  <span class="n">Position</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>    <span class="n">Rate</span><span class="p">(</span><span class="n">cM</span><span class="o">/</span><span class="n">Mb</span><span class="p">)</span>     <span class="n">Map</span><span class="p">(</span><span class="n">cM</span><span class="p">)</span>
<span class="n">chr1</span>        <span class="mi">55550</span>           <span class="mf">2.981822</span>        <span class="mf">0.000000</span>
<span class="n">chr1</span>        <span class="mi">82571</span>           <span class="mf">2.082414</span>        <span class="mf">0.080572</span>
<span class="n">chr1</span>        <span class="mi">88169</span>           <span class="mf">2.081358</span>        <span class="mf">0.092229</span>
<span class="n">chr1</span>        <span class="mi">254996</span>          <span class="mf">3.354927</span>        <span class="mf">0.439456</span>
<span class="n">chr1</span>        <span class="mi">564598</span>          <span class="mf">2.887498</span>        <span class="mf">1.478148</span>
<span class="o">...</span>
<span class="n">chr1</span>        <span class="mi">182973428</span>       <span class="mf">2.512769</span>        <span class="mf">122.832331</span>
<span class="n">chr1</span>        <span class="mi">183630013</span>       <span class="mf">0.000000</span>        <span class="mf">124.482178</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)"><em>str</em></a>) – The name of the file to be parsed. This may be
in plain text or gzipped plain text.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="msprime.RecombinationMap.uniform_map">
<em class="property">classmethod </em><code class="sig-name descname">uniform_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">length</span></em>, <em class="sig-param"><span class="n">rate</span></em>, <em class="sig-param"><span class="n">num_loci</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.RecombinationMap.uniform_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#msprime.RecombinationMap" title="msprime.RecombinationMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecombinationMap</span></code></a> instance in which the recombination
rate is constant over a chromosome of the specified length. The optional
<code class="docutils literal notranslate"><span class="pre">num_loci</span></code> controls the number of discrete loci in the underlying
simulation, and is by default large enough to be effectively be
a continuous model.</p>
<p>The following map can be used to simulate a true finite locus model
with a fixed number of loci <code class="docutils literal notranslate"><span class="pre">m</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">recomb_map</span> <span class="o">=</span> <span class="n">RecombinationMap</span><span class="o">.</span><span class="n">uniform_map</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">num_loci</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>length</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The length of the chromosome.</p></li>
<li><p><strong>rate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The rate of recombination per unit of sequence length
along this chromosome.</p></li>
<li><p><strong>num_loci</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The number of discrete loci in the underlying
simulation. By default this is set to a large number.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="simulation-models">
<span id="sec-api-simulation-models"></span><h2>Simulation models<a class="headerlink" href="#simulation-models" title="Permalink to this headline">¶</a></h2>
<p>The default simulation model in <code class="docutils literal notranslate"><span class="pre">msprime</span></code> is the standard coalescent with recombination
model. We also support a number of different models, which are documented in this section.</p>
<p>Simulations models are specified using the <code class="docutils literal notranslate"><span class="pre">model</span></code> parameter to
<a class="reference internal" href="#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>. This parameter can either take the form of a
string describing the model (e.g. <code class="docutils literal notranslate"><span class="pre">model=&quot;dtwf&quot;</span></code>) or an instance of a
model definition class (e.g <code class="docutils literal notranslate"><span class="pre">model=msprime.DiscreteTimeWrightFisher(1000)</span></code>).
The available models are documented in the following subsections.</p>
<p>A key element of simulation models in <code class="docutils literal notranslate"><span class="pre">msprime</span></code> is the concept
of a “reference population size”. The <code class="docutils literal notranslate"><span class="pre">Ne</span></code> argument to
<code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code> can also be used to define this parameter
when combined with a string shorthand for a model.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;dtwf&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">msprime</span><span class="o">.</span><span class="n">DiscreteTimeWrightFisher</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>
</pre></div>
</div>
<p>define the same simulation.</p>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>Add a discussion of population sizes here, describing
what Ne/model.reference_size really means, and how it interacts
with the individual population sizes.</p>
</div>
<p>We are often interested in simulating mixtures of models: for example,
using the <a class="reference internal" href="#msprime.DiscreteTimeWrightFisher" title="msprime.DiscreteTimeWrightFisher"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeWrightFisher</span></code></a> model to simulate the
recent past and then using the standard coalescent to complete the
simulation of the ancient past. This can be achieved using the
<a class="reference internal" href="#msprime.SimulationModelChange" title="msprime.SimulationModelChange"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationModelChange</span></code></a> event. See the
<a class="reference internal" href="tutorial.html#sec-tutorial-hybrid-simulations"><span class="std std-ref">Hybrid simulations</span></a> for an example of this
approach.</p>
<div class="section" id="coalescent-and-approximations">
<h3>Coalescent and approximations<a class="headerlink" href="#coalescent-and-approximations" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="msprime.StandardCoalescent">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">StandardCoalescent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reference_size</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.StandardCoalescent" title="Permalink to this definition">¶</a></dt>
<dd><p>The classical coalescent with recombination model (i.e., Hudson’s algorithm).
The string <code class="docutils literal notranslate"><span class="pre">&quot;hudson&quot;</span></code> can be used to refer to this model.</p>
<p>This is the default simulation model.</p>
</dd></dl>

<dl class="py class">
<dt id="msprime.SmcApproxCoalescent">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">SmcApproxCoalescent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reference_size</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.SmcApproxCoalescent" title="Permalink to this definition">¶</a></dt>
<dd><p>The original SMC model defined by McVean and Cardin. This
model is implemented using a naive rejection sampling approach
and so it may not be any more efficient to simulate than the
standard Hudson model.</p>
<p>The string <code class="docutils literal notranslate"><span class="pre">&quot;smc&quot;</span></code> can be used to refer to this model.</p>
</dd></dl>

<dl class="py class">
<dt id="msprime.SmcPrimeApproxCoalescent">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">SmcPrimeApproxCoalescent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reference_size</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.SmcPrimeApproxCoalescent" title="Permalink to this definition">¶</a></dt>
<dd><p>The SMC’ model defined by Marjoram and Wall as an improvement on the
original SMC. model is implemented using a naive rejection sampling
approach and so it may not be any more efficient to simulate than the
standard Hudson model.</p>
<p>The string <code class="docutils literal notranslate"><span class="pre">&quot;smc_prime&quot;</span></code> can be used to refer to this model.</p>
</dd></dl>

</div>
<div class="section" id="discrete-time-wright-fisher">
<h3>Discrete time Wright-Fisher<a class="headerlink" href="#discrete-time-wright-fisher" title="Permalink to this headline">¶</a></h3>
<p>Msprime provides the option to perform discrete-time Wright-Fisher simulations
for scenarios when the coalescent model is not appropriate, including large
sample sizes, multiple chromosomes, or recent migration.</p>
<p>To use this option, set the flag <code class="docutils literal notranslate"><span class="pre">model=&quot;dtwf&quot;</span></code> as in the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tree_sequence</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">sample_size</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mf">1e4</span><span class="p">,</span> <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">2e-8</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">model</span><span class="o">=</span><span class="s2">&quot;dtwf&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>All other parameters can be set as usual.</p>
<dl class="py class">
<dt id="msprime.DiscreteTimeWrightFisher">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">DiscreteTimeWrightFisher</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reference_size</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.DiscreteTimeWrightFisher" title="Permalink to this definition">¶</a></dt>
<dd><p>A discrete backwards-time Wright-Fisher model, with diploid back-and-forth
recombination. The string <code class="docutils literal notranslate"><span class="pre">&quot;dtwf&quot;</span></code> can be used to refer to this model.</p>
<p>Wright-Fisher simulations are performed very similarly to coalescent
simulations, with all parameters denoting the same quantities in both
models. Because events occur at discrete times however, the order in which
they occur matters. Each generation consists of the following ordered
events:</p>
<ul class="simple">
<li><p>Migration events. As in the Hudson coalescent, these move single extant
lineages between populations. Because migration events occur before
lineages choose parents, migrant lineages choose parents from their new
population in the same generation.</p></li>
<li><p>Demographic events. All events with <cite>previous_generation &lt; event_time &lt;=
current_generation</cite> are carried out here.</p></li>
<li><p>Lineages draw parents. Each (monoploid) extant lineage draws a parent
from their current population.</p></li>
<li><p>Diploid recombination. Each parent is diploid, so all child lineages
recombine back-and-forth into the same two parental genome copies. These
become two independent lineages in the next generation.</p></li>
<li><p>Historical sampling events. All historical samples with
<cite>previous_generation &lt; sample_time &lt;= current_generation</cite> are inserted.</p></li>
</ul>
</dd></dl>

</div>
</div>
<div class="section" id="initialising-simulations-from-a-tree-sequence">
<span id="sec-api-simulate-from"></span><h2>Initialising simulations from a tree sequence<a class="headerlink" href="#initialising-simulations-from-a-tree-sequence" title="Permalink to this headline">¶</a></h2>
<p>By default <code class="docutils literal notranslate"><span class="pre">msprime</span></code> simulations are initialised by specifying a set of samples,
using the <code class="docutils literal notranslate"><span class="pre">sample_size</span></code> or  <code class="docutils literal notranslate"><span class="pre">samples</span></code> parameters to <a class="reference internal" href="#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>. This
initialises the simulation with segments of ancestral material covering the
whole sequence. Simulation then proceeds backwards in time until a most recent
common ancestor has been found at all points along this sequence. We can
also start simulations from different initial conditions by using the
<code class="docutils literal notranslate"><span class="pre">from_ts</span></code> argument to <a class="reference internal" href="#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>. Informally, we take an ‘unfinished’
tree sequence as a parameter to simulate, initialise the simulation
from the state of this tree sequence and then run the simulation until
coalescence. The returned tree sequence is then the result of taking the
input tree sequence and completing the trees using the coalescent.</p>
<p>This is useful for forwards-time simulators such as
<a class="reference external" href="https://messerlab.org/slim/">SLiM</a> that can output tree sequences. By running
forward-time simulation for a certain number of generations we obtain a
tree sequence, but these trees may not have had sufficient time to
reach a most recent common ancestor. By using the <code class="docutils literal notranslate"><span class="pre">from_ts</span></code> argument
to <a class="reference internal" href="#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a> we can combine the best of both forwards- and
backwards-time simulators. The recent past can be simulated forwards
in time and the ancient past by the coalescent. The coalescent
simulation is initialised by the root segments of the
input tree sequence, ensuring that the minimal amount of ancestral
material possible is simulated.</p>
<p>Please see the <a class="reference internal" href="tutorial.html#sec-tutorial-simulate-from"><span class="std std-ref">tutorial</span></a> for an example of how to use this
feature with a simple forwards-time Wright-Fisher simulator</p>
<div class="section" id="input-requirements">
<h3>Input requirements<a class="headerlink" href="#input-requirements" title="Permalink to this headline">¶</a></h3>
<p>Any tree sequence can be provided as input to this process, but there is a
specific topological requirement that must be met for the simulations to be
statistically correct. To ensure that ancestral segments are correctly associated within chromosomes
when constructing the initial conditions for the coalescent simulation,
forward-time simulators <strong>must</strong> retain the nodes corresponding to the
initial generation. Furthermore, for every sample in the final generation
(i.e. the extant population at the present time) there must be a path
to one of the founder population nodes. (Please see the <a class="reference internal" href="tutorial.html#sec-tutorial-simulate-from"><span class="std std-ref">tutorial</span></a>
for further explanation of this point and an example.)</p>
</div>
<div class="section" id="recombination-map-limitations">
<h3>Recombination map limitations<a class="headerlink" href="#recombination-map-limitations" title="Permalink to this headline">¶</a></h3>
<p>Because of the way that <code class="docutils literal notranslate"><span class="pre">msprime</span></code> handles recombination internally, care must
be taken when specifying recombination when using the <code class="docutils literal notranslate"><span class="pre">from_ts</span></code> argument.
If recombination positions are generated in the same way in both the initial
tree sequence and the coalescent simulation, then everything should work.
However, the fine scale details of the underlying recombination model matter,
so matching nonuniform recombination maps between simulators may not be
possible at present. (To make it work, we must ensure that every recombination
breakpoint in <code class="docutils literal notranslate"><span class="pre">from_ts</span></code> matches exactly to a possible recombination
breakpoint in msprime’s recombination map, which is not guaranteed because of
msprime’s discrete recombination model.)</p>
<p>One case in which it is guaranteed to work is if <code class="docutils literal notranslate"><span class="pre">from_ts</span></code> has integer
coordinates, and we want to simulate a coalescent with a uniform recombination
rate. In this case, to have a uniform recombination rate <code class="docutils literal notranslate"><span class="pre">r</span></code> use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">L</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">from_ts</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">)</span>
<span class="n">recomb_map</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">RecombinationMap</span><span class="o">.</span><span class="n">uniform_map</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="n">final_ts</span> <span class="o">=</span> <span class="n">mpsrime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">from_ts</span><span class="o">=</span><span class="n">from_ts</span><span class="p">,</span> <span class="n">recomb_map</span><span class="o">=</span><span class="n">recomb_map</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="node-flags">
<span id="sec-api-node-flags"></span><h2>Node flags<a class="headerlink" href="#node-flags" title="Permalink to this headline">¶</a></h2>
<p>For standard coalescent simulations, all samples are marked with the
<a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.NODE_IS_SAMPLE" title="(in tskit v0.3)"><code class="xref py py-data docutils literal notranslate"><span class="pre">tskit.NODE_IS_SAMPLE</span></code></a> flag; internal nodes all have a flags value of 0.
When using the <code class="docutils literal notranslate"><span class="pre">record_full_arg</span></code> argument to <a class="reference internal" href="#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>, the following
flags values are defined:</p>
<dl class="py data">
<dt id="msprime.NODE_IS_RE_EVENT">
<code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">NODE_IS_RE_EVENT</code><a class="headerlink" href="#msprime.NODE_IS_RE_EVENT" title="Permalink to this definition">¶</a></dt>
<dd><p>The node is an ARG recombination event. Each recombination event is marked
with two nodes, one identifying the individual providing the genetic
material to the left of the breakpoint and the other providing the genetic
material the right.</p>
</dd></dl>

<dl class="py data">
<dt id="msprime.NODE_IS_CA_EVENT">
<code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">NODE_IS_CA_EVENT</code><a class="headerlink" href="#msprime.NODE_IS_CA_EVENT" title="Permalink to this definition">¶</a></dt>
<dd><p>The node is an ARG common ancestor event that did not result in
marginal coalescence.</p>
</dd></dl>

<dl class="py data">
<dt id="msprime.NODE_IS_MIG_EVENT">
<code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">NODE_IS_MIG_EVENT</code><a class="headerlink" href="#msprime.NODE_IS_MIG_EVENT" title="Permalink to this definition">¶</a></dt>
<dd><p>The node is an ARG migration event identifying the individual that migrated.
Can be used in combination with the <code class="docutils literal notranslate"><span class="pre">record_migrations</span></code> argument to
<a class="reference internal" href="#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a>.</p>
</dd></dl>

<dl class="py data">
<dt id="msprime.NODE_IS_CEN_EVENT">
<code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">NODE_IS_CEN_EVENT</code><a class="headerlink" href="#msprime.NODE_IS_CEN_EVENT" title="Permalink to this definition">¶</a></dt>
<dd><p>The node was created by a <a class="reference internal" href="#msprime.CensusEvent" title="msprime.CensusEvent"><code class="xref py py-class docutils literal notranslate"><span class="pre">msprime.CensusEvent</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="simulating-mutations">
<h2>Simulating mutations<a class="headerlink" href="#simulating-mutations" title="Permalink to this headline">¶</a></h2>
<p>When running coalescent simulations it’s usually most convenient to use the
<code class="docutils literal notranslate"><span class="pre">mutation_rate</span></code> argument to the <a class="reference internal" href="#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a> function to throw neutral
mutations down on the trees. However, sometimes we wish to throw mutations
down on an existing tree sequence: for example, if we want to see the outcome
of different random mutational processes on top of a single simulated topology,
or if we have obtained the tree sequence from another program and wish to
overlay neutral mutations on this tree sequence.</p>
<dl class="py class">
<dt id="msprime.InfiniteSites">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">InfiniteSites</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">alphabet</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.InfiniteSites" title="Permalink to this definition">¶</a></dt>
<dd><p>The “infinitely many sites” mutation model. In this model each mutation
corresponds to a unique site, which has a floating-point position chosen
uniformly along the sequence. As a result, each site is associated with
exactly one mutation.</p>
<p>By default, the ancestral and derived states in this model are
represented by the characters “0” and “1”. Thus, the ancestral state
at a site is always “0” and the derived state for a mutation is
always “1”. However, by specifying the <code class="docutils literal notranslate"><span class="pre">alphabet=NUCLEOTIDES</span></code> we
can generate mutations from the nucleotide characters ACGT. In this
case, for each mutation an ancestral state is chosen uniformly from
these letters. The derived state is then chosen uniformly from the
<em>remaining</em> characters so that the ancestral and derived states
are always distinct.</p>
</dd></dl>

<dl class="py data">
<dt>
<code class="sig-name descname">msprime.BINARY == 0</code></dt>
<dd><p>The binary mutation alphabet where ancestral states are always “0” and
derived states “1”.</p>
</dd></dl>

<dl class="py data">
<dt>
<code class="sig-name descname">msprime.NUCLEOTIDES == 1</code></dt>
<dd><p>The nucleotides mutation alphabet in which ancestral and derived states are
chosen from the characters “A”, “C”, “G” and “T”.</p>
</dd></dl>

<dl class="py function">
<dt id="msprime.mutate">
<code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">mutate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tree_sequence</span></em>, <em class="sig-param"><span class="n">rate</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">random_seed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">model</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keep</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">start_time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">end_time</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#msprime.mutate" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulates mutations on the specified ancestry and returns the resulting
<a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.TreeSequence</span></code></a>. Mutations are generated at the specified rate in
measured generations. Mutations are generated under the infinite sites
model, and so the rate of new mutations is per unit of sequence length per
generation.</p>
<p>If a random seed is specified, this is used to seed the random number
generator. If the same seed is specified and all other parameters are equal
then the same mutations will be generated. If no random seed is specified
then one is generated automatically.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">model</span></code> parameter is specified, this determines the model under
which mutations are generated. Currently only the <a class="reference internal" href="#msprime.InfiniteSites" title="msprime.InfiniteSites"><code class="xref py py-class docutils literal notranslate"><span class="pre">InfiniteSites</span></code></a>
mutation model is supported. This parameter is useful if you wish to obtain
sequences with letters from the nucleotide alphabet rather than the default
0/1 states. By default mutations from the infinite sites model with a binary
alphabet are generated.</p>
<p>By default, sites and mutations in the parameter tree sequence are
discarded. If the <code class="docutils literal notranslate"><span class="pre">keep</span></code> parameter is true, however, <em>additional</em>
mutations are simulated. Under the infinite sites mutation model, all new
mutations generated will occur at distinct positions from each other and
from any existing mutations (by rejection sampling).</p>
<p>The time interval over which mutations can occur may be controlled
using the <code class="docutils literal notranslate"><span class="pre">start_time</span></code> and <code class="docutils literal notranslate"><span class="pre">end_time</span></code> parameters. The <code class="docutils literal notranslate"><span class="pre">start_time</span></code>
defines the lower bound (in time-ago) on this interval and <code class="docutils literal notranslate"><span class="pre">max_time</span></code>
the upper bound. Note that we may have mutations associated with
nodes with time &lt;= <code class="docutils literal notranslate"><span class="pre">start_time</span></code> since mutations store the node at the
bottom (i.e., towards the leaves) of the branch that they occur on.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tree_sequence</strong> (<a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><em>tskit.TreeSequence</em></a>) – The tree sequence onto which we
wish to throw mutations.</p></li>
<li><p><strong>rate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The rate of mutation per generation. (Default: 0).</p></li>
<li><p><strong>random_seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The random seed. If this is <cite>None</cite>, a
random seed will be automatically generated. Valid random
seeds must be between 1 and <span class="math notranslate nohighlight">\(2^{32} - 1\)</span>.</p></li>
<li><p><strong>model</strong> (<em>MutationModel</em>) – The mutation model to use when generating
mutations. If not specified or None, the <a class="reference internal" href="#msprime.InfiniteSites" title="msprime.InfiniteSites"><code class="xref py py-class docutils literal notranslate"><span class="pre">InfiniteSites</span></code></a>
mutation model is used.</p></li>
<li><p><strong>keep</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a>) – Whether to keep existing mutations (default: False).</p></li>
<li><p><strong>start_time</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The minimum time at which a mutation can
occur. (Default: no restriction.)</p></li>
<li><p><strong>end_time</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The maximum time at which a mutation can occur
(Default: no restriction).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.TreeSequence</span></code></a> object  resulting from overlaying
mutations on the input tree sequence.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.TreeSequence</span></code></a></p>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="cli.html" class="btn btn-neutral float-right" title="Command line interface" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="tutorial.html" class="btn btn-neutral float-left" title="Tutorial" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2015-2019, Jerome Kelleher.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>